#!/bin/bash
# Copyright (c) 2000 SuSE GmbH Nuernberg, Germany.  All rights reserved.
#
# Authors: Joachim Schroeder <Joachim.Schroeder@suse.de>
#          Bernd Kaindl <Bernd.Kaindl@suse.de>
#
#	Save it for autoconfig
AUTO_PEER="$PEER"
# network setup script and linuxrc for s390-suse-linux
#
# Default environment variables:
#
# first, the network device parameters
: ${DEVNO:=auto} ${DEVNO2:=auto} ${DEVNO3:=auto} ${PORTNO:=0} ${PEER:=TCPIP}
: ${PORTNAME:=suselin7} ${PROTOCOL:=noproto}
#
# c7000 parameters:
: ${LHOST:=UTS} ${UHOST:=C7011} ${LAPPL:=TCPIP} ${UAPPL:=TCPIP} ${DBG:=0}
#
# and export them:
export DEVNO DEVNO2 DEVNO3 PORTNAME PORTNO PEER LHOST UHOST LAPPL UAPPL DBG
#
# second, the network connection parameters
: ${IP_HOST:=linux.example.com}
: ${IP_ADDR:=192.168.0.1}
: ${IP_NETMASK:=255.255.255.0}
: ${IP_GATEWAY:=192.168.0.254}
: ${IP_PEER:=192.168.0.254}
: ${IP_DNS:=none}
# Take it from the domain of IP_HOST
#: ${IP_SEARCH:=example.com}
: ${IP_MTU:=default}
: ${SCH_ORDER:=DeviceAddr}
: ${DONTSHOW:=^....   ....  3390}
#
export IP_HOST
export IP_ADDR
export IP_NETMASK
export IP_GATEWAY
export IP_PEER
export IP_DNS
export IP_SEARCH
export IP_MTU
#
[ "$LINUXRC_RECORD" ] && LINUXRC_READ=""
#
# readln reads a line into $ANSW.
#
function readln () {
  echo -n "$1"
  if [ -z "$LINUXRC_RECORD" -a "$LINUXRC_READ" ]; then
    set -- $LINUXRC_READ
    echo "-> $1"
    ANSW=$1
    shift
    LINUXRC_READ="$@"
    [ "$ANSW" = /n -o "$ANSW" = /N ] && ANSW=""
    sleep 1
  else
    IFS='@' read ANSW || exit 1
    ANSW=`echo $ANSW | sed -e 's/^ *//'`
    if [ "$LINUXRC_RECORD" ]; then
      record_answ="$ANSW"
      [ "$record_answ" ] || record_answ=/n
      LINUXRC_READ="$LINUXRC_READ $record_answ"
    fi
    if [ "$ANSW" = "restart" -o "$ANS" = "RESTART" ]; then
	echo;echo;echo "-- Restarting linuxrc --";echo;echo
	if [ "$DEBUG" = "yes" ]; then
	    . ./linuxrc || exit 1
	else
	    . /linuxrc || exit 1
	fi
	exit 0
    fi
  fi
}
#
#
# yes_no reads either a yes or a no into $ANSW
#
function yes_no () {
  while :; do
    readln "$1"
    case "$ANSW" in
      [yY] | [yY][eE][sS]) ANSW=yes
                     break;;
      [nN] | [nN][oO])  ANSW=no
                     break;;
    esac
  done
}
#
#
# Check memory and issue a waring if we do not have a certain amount
#
function check_memory () {
	set -- `cat /proc/meminfo | head -2 | tail -1`
	# 1GB of memory is enough and bash cannot use nums >2^31 (signed int)
	[ ${#2} -gt 9 ] && return
	let MEM="$2/1024/1024"
	if [ $MEM -lt 80 ]; then
	    echo "Warning: The kernel has only $MEM MB memory for applications"
	    echo "80 MB are recommended for installation thru FTP and updating."
	fi
}
#
function write_chandev {
    echo "Writing '$*' to /proc/chandev"
    echo "$*" > /proc/chandev
}
#
#
#
function shutdown_reset_conf_chandev {
     write_chandev "shutdown"
     write_chandev "reset_conf"
}
#
function ask_select_protocol() {
    NO_ERROR=yes
    while :; do
      echo "Select protocol number for $NETTYPE:"
      echo "0) Compatibility mode, also for non-Linux peers other"
      echo "   than OS/390 and z/OS (this is the default mode)"
      echo "1) Extended mode"
      echo "3) Compatibility mode with OS/390 and z/OS"
      if [ "$AUTOINSTALL" = "yes"  -a "$NO_ERROR" = "yes" ]
      then
		echo "Enter your choice ($PROTOCOL): $PROTOCOL"
		ANSW=$PROTOCOL
      else
		PROTOCOL=0
		readln "Enter your choice ($PROTOCOL): "
      fi
      [ "$ANSW" ] && PROTOCOL="$ANSW"
      case "$PROTOCOL" in
	0|1|3)
           return ;;
	*)
	   PROTOCOL=""
           echo "This is not a valid menu option, redisplaying menu:";;
      esac
      NO_ERROR=no
    done
}
#
function hwconfig_menu () {
    while :; do
      echo
      echo "Check HW configuration/detection:"
      echo "1) Show all detected subchannels"
      echo "2) Show only subchannels that match a search expression"
#     echo "3) Change sort order of subchannel display: $SCH_ORDER"
#     echo "4) Change pattern of channels which are not shown: $DONTSHOW"
      echo "5) Show the full output of /proc/chandev"
      echo "6) Show detected devices of /proc/chandev"
      echo "7) Show detected devices of /proc/chandev that match a search expression"
      echo "8) Show devices enabled for detection in /proc/chandev"
      echo "9) Return to main menu"
      echo
      readln "Enter your choice (1-9): "
      case "$ANSW" in
	1)
	  echo "Showing all detected subchannels(dasd channels not shown):"
          show_subchannels | grep -v "$DONTSHOW"
	  press_return_to_continue
	  ;;
	2)
	  readln "Enter search expression: "
	  echo "Showing subchannels that match $ANSW(dasd channels not shown):"
          show_subchannels | grep -v "$DONTSHOW" | grep "$ANSW" >subchannels
	  if [ -s subchannels ]; then
		cat subchannels
	  else
		echo "No non-dasd subchannels matched $ANSW."
	  fi
	  press_return_to_continue
          ;;
#       3)
#         echo "Select new sort order"
#         ;;
#       4)
#         echo "Change pattern of channels which are not shown:"
#         ;;
        5)
	  echo "============================================================================="
	  echo "        Showing the contents of /proc/chandev(compressed output)"
	  echo "============================================================================="
	  sed -n 's/\(................................................................................\).*/\1/
			/^[=*]/d;
	       s/0x10  0x1731 0x01  0x1732 0x01/OSA Express Eth or Gigabit Eth/;
	       s/0x10  0x1731 0x05  0x1732 0x05/Hipersocket:(1731-05, 1732-05)/;
	       s/^0x//;s/^ //;s/0x/  /g;/./p' /proc/chandev
		  press_return_to_continue
	  ;;
        6)
	  echo "Showing the channels detected section of /proc/chandev:"
	  sed -n '1,/^channels detected/d;s/ *$//;/^[ =0]/p' /proc/chandev >channels
	  if [ -s channels ]; then
	  sed 's/0x10  0x1731 0x01  0x1732 0x01/OSA Express Eth or Gigabit Eth/;
               s/0x10  0x1731 0x05  0x1732 0x05/Hipersocket:(1731-05, 1732-05)/;
	       s/^0x//;s/^ //;s/0x/  /g;' channels
	  else
		echo "/proc/chandev does not show detected devices."
	  fi
	  press_return_to_continue
	  ;;
        7)
	  echo "Showing the channels detected section of /proc/chandev that match $ANSW:"
	  sed -n '1,/^channels detected/d;s/ *$//;/^[ =0]/p' /proc/chandev >channels
	  if [ -s channels ]; then
	        readln "Enter search expression: "
		grep "$ANSW" channels
	  else
		echo "/proc/chandev does not show detected devices."
	  fi
	  press_return_to_continue
	  ;;
        8)
	  echo "Showing the enabled channels of /proc/chandev, only the first 80 columns:"
          echo "The output is clipped at column 80 to fit on 80 column terminals"
	  echo "Channels enabled for detection:"
          sed '1,/^Channels enabled/d;/^$/,$d;s/\(................................................................................\).*/\1/' /proc/chandev
	  ;;
        9)
	  break;;
        *)
          echo "This is not a valid menu option, redisplaying menu:";;
      esac
    done
}
#
#
# Show all detected subchannels (in subchannel order) with their device IDs:
#
function show_subchannels () {
	cat /proc/subchannels
}
#
#
# Ask to press return to continue:
#
function press_return_to_continue () {
        echo -n "Press ENTER to continue: "
	read a
}
#
#
# Ask if the user want to see all detected subchannels:
#
function ask_show_subchannels () {
        yes_no "Do you want to see all detected (non-DASD) subchannels? (yes/no) "
        if [ "$ANSW" = "yes" ]; then
		show_subchannels | grep -v "^....   ....  3390"
		press_return_to_continue
	fi
}
#
#
# execcmd executes a command or displays it in debug mode
#
function execcmd () {
	CMD="$*"
	if [ "$DEBUG" = "yes" ]; then
		echo "--> "$CMD
	else
		eval $CMD
	fi
	EXIT_CODE=$?
}
#
#
# change_passwd asks for a new root password
#
function change_passwd() {
  echo " "
  echo "For security reasons you have to set an temporary installation"
  echo "system password for the user \"root\"."
  echo "You'll be asked for it only when you telnet into this installation"
  echo "system to limit the access to it and it will be cleared as soon"
  echo "as you shut down or reset the installation system"
  NO_ERROR=yes
  while :; do
    echo " "
    if [ "$AUTOINSTALL" = "yes" -a "$NO_ERROR" = "yes" ]
    then
	    echo "Please enter the temporary installation password: $INST_PASSWORD"
	    ANSW=$INST_PASSWORD
    else
	    readln "Please enter the temporary installation password: "
    fi
    [ ${#ANSW} -ge 3 ] && break;
    echo "Please enter at least 3 characters."
    NO_ERROR=no
  done
  echo "root:$ANSW" | execcmd "/usr/sbin/chpasswd" &&
    echo "Temporary installation password set."
}
#
#
# show_license shows the LCS license
#
show_license () {
  TOTAL=1
  FIRST=1
  SHOWED=0
  while read LINE
   do
     echo "$LINE"
     (( SHOWED = SHOWED + 1 ))
     if [ $SHOWED -ge 32 ]; then
       (( LAST = TOTAL + SHOWED ))
       echo -n "(lines $TOTAL to $LAST) press ENTER:"
       read A < /dev/tty
       [ "$A" = q ] && return 1
       (( TOTAL = TOTAL + SHOWED ))
       SHOWED=0
     fi
   done
}
#
#
# display_license validates that the license is being read
#
function display_license() {
  [ "$LICENSE_ACKNOWLEGED" = yes ] && return
  [ "$DEBUG" = "yes" -o "$LINUXRC_RECORD" -o "$LINUXRC_READ" ] && return
  echo "To set up the network, you have to read and confirm the license information"
  echo "of the network device driver provided by IBM."
  yes_no "Do you want to see the license (Yes/No) ? "
  if [ "$ANSW" = "yes" ]; then
show_license <<EOF
-------------------------------------------------------------------------------
International License Agreement for Non-Warranted Programs

General Terms

     The Program is owned by International Business Machines Corporation or one
     of its subsidiaries (IBM) or an IBM supplier, and is copyrighted and
     licensed, not sold.

     The term "Program" means the original program and all whole or partial
     copies of it. A Program consists of machine-readable instructions, its
     components, data, audio-visual content (such as images, text, recordings,
     or pictures), and related licensed materials.

     This Agreement is the complete agreement regarding the use of this Program,
     and replaces any prior oral or written communications between you and IBM.

     1. License

     Use of the Program

     IBM grants you a nonexclusive license to use the Program.

     You may 1) use the Program to the extent of authorizations you have
     acquired and 2) make, install and distribute copies to support the level of
     use authorized, providing you reproduce the copyright notice and any other
     legends of ownership on each copy, or partial copy, of the Program and that
     you provide a copy of this International License Agreement for
     Non-Warranted Programs along with the distribution of each copy or partial
     copy of the Program.

     You will ensure that anyone who uses the Program does so only in compliance
     with the terms of this Agreement.

     You may not 1) use, copy, modify, or distribute the Program except as
     provided in this Agreement; 2) reverse assemble, reverse compile, or
     otherwise translate the Program except as specifically permitted by law
     without the possibility of contractual waiver; or 3) sublicense, rent, or
     lease the Program.

     2. No Warranty

     SUBJECT TO ANY STATUTORY WARRANTIES WHICH CAN NOT BE EXCLUDED, IBM MAKES NO
     WARRANTIES OR CONDITIONS EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
     LIMITATION, THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES OF
     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, REGARDING THE PROGRAM
     OR TECHNICAL SUPPORT, IF ANY. IBM MAKES NO WARRANTY REGARDING THE
     CAPABILITY OF THE PROGRAM TO CORRECTLY PROCESS, PROVIDE AND/OR RECEIVE DATE
     DATA WITHIN AND BETWEEN THE 20TH AND 21ST CENTURIES.

     The exclusion also applies to any of IBM's subcontractors, suppliers, or
     program developers (collectively called "Suppliers").

     Manufacturers, suppliers, or publishers of non-IBM Programs may provide
     their own warranties.

     3. Limitation of Liability

     NEITHER IBM NOR ITS SUPPLIERS WILL BE LIABLE FOR ANY DIRECT OR INDIRECT
     DAMAGES, INCLUDING WITHOUT LIMITATION, LOST PROFITS, LOST SAVINGS, OR ANY
     INCIDENTAL, SPECIAL, OR OTHER ECONOMIC CONSEQUENTIAL DAMAGES, EVEN IF IBM
     IS INFORMED OF THEIR POSSIBILITY. SOME JURISDICTIONS DO NOT ALLOW THE
     EXCLUSION OR LIMITATION OF INCIDENTAL OR CONSEQUENTIAL DAMAGES, SO THE
     ABOVE EXCLUSION OR LIMITATION MAY NOT APPLY TO YOU.

     4. General

     Nothing in this Agreement affects any statutory rights of consumers that
     cannot be waived or limited by contract.

     IBM may terminate your license if you fail to comply with the terms of this
     Agreement. If IBM does so, you must immediately destroy the Program and all
     copies you made of it.

     You agree to comply with applicable export laws and regulations.

     Neither you nor IBM will bring a legal action under this Agreement more
     than two years after the cause of action arose unless otherwise provided by
     local law without the possibility of contractual waiver or limitation.

     Neither you nor IBM is responsible for failure to fulfill any obligations
     due to causes beyond its control.

     IBM does not provide program services or technical support, unless IBM
     specifies otherwise.
------------------------------------------------------------------------------'
EOF
    echo
    yes_no "Do you agree with this license (Yes/No) ? "
    if [ "$ANSW" = "no" ]; then
      no_network
      EXIT_SCRIPT=1
      return 1
    else
      export LICENSE_ACKNOWLEGED=yes
      echo
      echo "Ok, now we can set up the network configuration."
    fi
  else
    no_network
    EXIT_SCRIPT=1
    return 1
  fi
}
#
function set_IP_DEV {
  [ "$NETSELECT" = "tr" ]    && IP_DEV=tr0
  [ "$NETSELECT" = "eth" ]   && IP_DEV=eth0
  [ "$NETSELECT" = "qeth" ]  && IP_DEV=eth0
  [ "$NETSELECT" = "hsi" ]   && IP_DEV=hsi0
  [ "$NETSELECT" = "ctc" ]   && IP_DEV=ctc0
  [ "$NETSELECT" = "escon" ] && IP_DEV=escon0
  [ "$NETSELECT" = "iucv" ]  && IP_DEV=iucv0
  [ "$NETSELECT" = "c7000" ] && IP_DEV=ci0
}
#
#
# select_network_device_type lets you choose the network connection
#
function select_network_device_type() {
    if [ "$NETSELECT" -a "$NETSELECT" != none ]; then
      echo "The selected network device type is $NETSELECT."
      yes_no "Do you want to change it (Yes/No) ?"
      [ "$ANSW" = no ] && return
    fi
    check_memory
    NO_ERROR="yes"
    while :; do
      CHAN=""
      echo
      echo "Please select the type of your network device:"
      echo "0) no network"
      echo "1) OSA Token Ring"
      echo "2) OSA Ethernet"
      echo "3) OSA-Gigabit Ethernet or OSA-Express Fast Ethernet"
      echo "4) Channel To Channel"
      echo "5) Escon"
      echo "6) IUCV"
#     The UTS c7000 driver has not been ported to 2.4 yet:
#      if [ "`uname -r`" = 2.2.19 ]; then
#        echo "7) CLAW (Cisco Mainframe Channel Connection)"
#      fi
      echo "8) Hipersockets"
      echo "9) Show subchannels and detected devices"
      if [ "$AUTOINSTALL" = "yes" -a "$NO_ERROR" = "yes" ]
      then
		case "$IP_INTERFACE" in
			tr) ANSW=1;;
			eth) ANSW=2;;
			qeth) ANSW=3;;
			ctc) ANSW=4;;
			escon) ANSW=5;;
			iucv) ANSW=6;;
#			c7000) ANSW=7;;
			hsi) ANSW=8;;
		esac
      else
		readln "Enter your choice (0-9): "
      fi
      echo
      case "$ANSW" in
	0)
#	  no network
	  NETSELECT="none"
          EXIT_SCRIPT=1
          no_network
	  break;;
        1)
	  NETSELECT="tr"
	  set_IP_DEV
	  if load_LCS; then
	      break
          fi;;
        2)
	  NETSELECT="eth"
	  set_IP_DEV
	  if load_LCS; then
	      break
          fi;;
        3)
 	  NETSELECT="qeth"
	  set_IP_DEV
          if load_QETH; then
              break
          fi;;
        4)
	  NETSELECT="ctc"
	  set_IP_DEV
          if load_CTC; then
            break
          fi;;
        5)
	  NETSELECT="escon"
	  set_IP_DEV
          if load_CTC; then
	    break
          fi;;
        6)
	  NETSELECT="iucv"
	  set_IP_DEV
          if load_IUCV; then
            break
          fi;;
#       7)
#         NETSELECT="c7000"
#         set_IP_DEV
#         if load_C7000; then
#           break
#         fi;;
        8)
          NETSELECT="hsi"
	  set_IP_DEV
	  if load_QETH; then
	    break
	  fi;;
        9)
          hwconfig_menu
	  ;;
        *)
          echo "This is not a valid menu option, redisplaying menu:";;
      esac
      NO_ERROR=no
    done
}
#
#
# activate_config establishes the network connection
# 
function activate_config() {
    export HOSTNAME=${IP_HOST%%.*}
    execcmd "/bin/hostname $HOSTNAME"
    dns_config
    ANSW="y"
    while [ "$ANSW" = "y" ] ; do
	IFCONFIG="ifconfig $IP_DEV $IP_ADDR"
	case "$NETSELECT" in
	    tr|eth|qeth|c7000|hsi)
		IFCONFIG="$IFCONFIG netmask $IP_NETMASK broadcast $IP_BROADCAST" ;;
	    ctc|escon|iucv)
		IFCONFIG="$IFCONFIG pointopoint $IP_PEER" ;;
	esac
	if [ $IP_MTU != 0 ]; then
	    IFCONFIG="$IFCONFIG mtu $IP_MTU"
	fi
	echo "$IFCONFIG"
	execcmd "/sbin/$IFCONFIG"
	echo "/sbin/ifconfig $IP_DEV :"
	execcmd "/sbin/ifconfig $IP_DEV"
        sleep 1
	echo "Trying to ping my IP address:"
	execcmd "ping -w 10 -n -c 3 $IP_ADDR"
	if [ $EXIT_CODE -gt 0 ]; then
	    echo "Warning: Could not ping my IP address!"
	else
	    case "$NETSELECT" in
		tr|eth|qeth|hsi|c7000)
                    NTRY=3
                    if [ "$NETSELECT" = qeth ]; then
                        echo -n "Waiting 12s for network device $IP_DEV."
			for i in 1 2 3 4 5 6 7 8 9 a b;do sleep 1;echo -n .;done
			echo ..done.
		    fi
		    if [ "$IP_GATEWAY" ]; then
			echo "Trying to ping the IP address of the Gateway:"
			execcmd "ping -w 10 -n -c $NTRY $IP_GATEWAY" 
			if [ $EXIT_CODE -eq 0 ]; then
			    echo "Gateway seems to respond to our pings, continuing."
			    break
			else
			    echo "Warning: The gateway address $IP_GATEWAY did not ping."
			fi
		    fi
		    ;;
		ctc|escon|iucv)
		    if [ "$IP_PEER" ]; then
                        if [ "$NETSELECT" != iucv ]; then
			    for i in 6 3 4 5 4 4 3 2
			    do
				if dmesg | tail | grep -q "$IP_DEV: connected with remote side"; then
					break
				fi
				echo "Waiting $i seconds for connection with remote side."
				sleep $i
			    done
			fi
			echo "Trying to ping the IP address of the peer:"
			execcmd "ping -w 10 -n -c 3 $IP_PEER"
			if [ $EXIT_CODE -eq 0 ]; then
			    echo "Peer seems to respond to our pings, continuing."
			    break
			else
			    echo "Warning: The peer address $IP_PEER did not ping."
			    case "$NETSELECT" in
				ctc|escon)
				    echo "Statistics from $IP_DEV:"
				    cat /proc/net/ctc/$IP_DEV/statistics
				;;
			    esac
			fi
		    fi
		    ;;
		*)
		    echo "Something went wrong with $NETSELECT..."
	    esac
	fi
	readln "Do you want to retry the ifconfig (y/n)? "
    done
    if test $IP_GATEWAY ; then
      execcmd "route add default gw $IP_GATEWAY"
    fi
    if [ "$IP_DNS" ]; then
	echo "Trying to ping the IP address of the DNS Server:"
	execcmd "ping -w 10 -c 3 $IP_DNS"
	if [ $EXIT_CODE -gt 0 ]; then
	    echo "Warning: The DNS address $IP_DNS did not ping."
	    echo "Diagnostics:"
	    echo "traceroute to the DNS IP with max ttl 10, waittime 1, one probe per hop:"
	    execcmd "traceroute -m 10 -n -w 1 -q 1 $IP_DNS"
	    echo "Flaky DNS will cause delays when logging in and during"
	    echo "Installation. To disable DNS enter: \"nodns\"."
	fi
    fi
    generate_installinf >$INSTALLINF
}
#
#
#
generate_installinf () {
#
# the following lines are not needed in install.inf
#Display: Color
#Keytable: de-lat1-nd
#Bootmode: CD
#Cdrom: /dev/hda
#Server:  10.10.0.10
#Serverdir: /work/CDs/full-i386
#Language: english
#
    echo "Bootmode: Net
Sourcemounted: 0
Netdevice: $IP_DEV
IP: $IP_ADDR"
    [ $IP_MTU != 0 ] && echo "MTU: $IP_MTU"
    case "$NETSELECT" in
	tr|eth|qeth|hsi|c7000)
	    echo "Netmask: $IP_NETMASK"
	    echo "Broadcast: $IP_BROADCAST"
#	for qeth and hsi
	    [ "$NETSELECT" = "qeth" -a "$NETSELECT" = "hsi" ] && echo "WAIT_FOR_INTERFACES: 15"
	    ;;
	ctc|escon|iucv)
#
#	KRUECKE TODO
#	We need a networkmask to get linuxrc in batch-mode
#
	    echo "Netmask: $IP_NETMASK"
	    echo "Pointopoint: $IP_PEER"
#	Only for ctc and escon
	    [ ! "$NETSELECT" = "iucv" ] && echo "WAIT_FOR_INTERFACES: 40"
	    ;;
	*)
	    echo "Something went wrong with $NETSELECT..." >&2
    esac
    [ "$IP_GATEWAY" ] && echo "Gateway: $IP_GATEWAY"
    [ "$IP_SEARCH" ]  && echo "Domain: $IP_SEARCH"
    [ "$CHAN" ]       && echo "Chandev: $CHAN"
    if [ "$NETSELECT" = tr -o "$NETSELECT" = eth ]; then
      echo "Alias: $IP_DEV lcs"
#      echo "Options: lcs $PARM"
      echo "ConnectWait: 3"
    fi
    if [ "$NETSELECT" = "qeth" -o "$NETSELECT" = hsi ]; then
      echo "Alias: $IP_DEV qeth"
#      echo "Options: qeth $PARM"
      echo "ConnectWait: 15"
    fi
    if [ "$NETSELECT" = "ctc" -o "$NETSELECT" = "escon" ]; then
#      echo "Alias: $IP_DEV ctc"
#      echo "Options: ctc $PARM"
      echo "ConnectWait: 30"
    fi
    if [ "$NETSELECT" = "c7000" ]; then
      echo "Alias: $IP_DEV c7000"
      echo "Options: c7000 $PARM"
    fi
    if [ "$NETSELECT" = "iucv" ]; then
#      echo "Alias: $IP_DEV netiucv"
      echo "$PARM" | sed "s/iucv=\(.*\)/Options: netiucv iucv=\1/g"
    fi
    [ "$IP_HOST" ]        && echo "Machinename: $IP_HOST"
    [ "$IP_DNS" ]         && echo "Nameserver: $IP_DNS"
    [ "$IP_MTU" != 0 ]    && echo "IP_MTU: $IP_MTU"
}
#
#
# at the end, run services
#
function run_services () {
  echo "Network Setup finished, running inetd..."
  echo pts/0 >> /etc/securetty
  echo pts/1 >> /etc/securetty
  echo pts/2 >> /etc/securetty
  execcmd "/usr/sbin/inetd &"
  execcmd "/sbin/portmap &"
  echo
  echo "You should be able to login via telnet now, for ssh wait a few seconds,"
  echo "temporary host keys (only for installation) are being generated now:"
  echo
  execcmd "/etc/init.d/sshd start"
  echo
  echo "Generation of temporary installation host keys finished."
  echo "After installation, new, different SSH keys will be generated."
  echo
# /usr/sbin/rpc.mountd -d call &
# /usr/sbin/rpc.nfsd -d auth &
}
#
#
# configure name resolving
#
function dns_config () {
  if [ "$DEBUG" = "yes" ]; then echo "-->(Installing /etc/resolv.conf)";return; fi
  cat > /etc/resolv.conf <<EOF
#
# /etc/resolv.conf
#
# Automatically generated by SuSE S/390 linuxrc (network setup)
#
# PLEASE DO NOT EDIT THIS FILE!
#
search $IP_SEARCH
nameserver $IP_DNS
EOF
}
#
#
# on failure, quit with this message
#
function no_network () {
  echo
  echo "*** OK, NETWORK ACCESS WILL _NOT_ BE AVAILABLE. ***"
  echo
}
function err () {
	echo "$@" >&2
}

#
function check_qeth_channels () {
    IFS="," read read write data rest
    if [ "$read" = auto ]; then
	echo auto
	return 0
    fi
    if [ -z "$read" -o -z "$write" -o -z "$data" ]; then
	err "qeth needs 3 four-digit hexadecimal numbers delimited by commas(,)."
	echo "$DEVS"
	return 1
    fi
    err=0
    for channel in read write data
    do
	eval devno=\$${channel}
        devno=${devno#0x}
        [ $channel != read ] && echo -n ,
	if [ "$devno" != "${devno//[^0-9a-fA-F]/}" ]; then
           echo -n "[0x$devno]"
	   err "$channel channel address $devno contains non-hex characters, please check."
	   return 1
	fi
	devno=`printf %d 0x${devno}`
	if [ ${devno} -lt 0 -o ${devno} -gt 65535 ]; then
           printf '[0x%04x]' "$devno"
	   err "$channel channel address ${devno#0x} must be between 0 and 0xffff"
	   return 1
	fi
	devno=`printf %04x ${devno}`
        CHPIDs=`sed -n "s/^${devno} \([0-9a-f]*\) */\1/p" chandet.qeth`
	if [ -z "$CHPIDs" ]; then
	   err "$channel channel address ${devno} not found, please check."
	   return 1
	fi
	if [ "${last_CHIPDs}" -a "${CHPIDs}" != "${last_CHIPDs}" ]; then
	   err "$channel channel is CHPID ${CHPIDs//00/} while ${last_channel} channel is CHPID ${last_CHPIDs//00/}."
	   return 1
	fi
        eval ${channel}=0x${devno}
	if [ "$NETSELECT" = qeth ]; then
	  if [ $channel = read  -a $(($read & 1)) -eq 1 ]; then
		err "read channel address is odd, must be even!(incremented)"
		read="$(($read + 1))"
		err=1
	  fi
	  if [ $channel = write -a $(($read + 1)) -ne $(($write)) ]; then
		err "write channel address must be the read channel address plus 1(corrected)"
		write="$(($read + 1))"
		err=1
	  fi
	fi
        last_channel=${channel}
        last_CHIPDs=${CHPIDs}
	echo -n "0x$devno"
    done
    #echo -n "${read},${write},${data}"
    [ "${rest}" ] && echo ",${rest}"
    return $err
}
#
#
#
function print_qeth_ranges () {
    IFS="," read read write data rest
    if [ $(($read - 1)) -eq $(($data)) ]; then
	echo "$data,$write"
    elif [ $(($write + 1)) -eq $(($data)) ]; then
	echo "$read,$data"
    else
	echo "$read,$write"
	echo "$data"
    fi
}
#
#
# ask for lcs parameters for OSA devices
#
function load_LCS_chandev () {
  sed -n '1,/^channels detected/d;/^ /p;/^0x.... 0x.... 0x0[4567]/p' \
	 /proc/chandev | cut -c 8-80 >lcs_detected
  if [ `grep '^0' lcs_detected | wc -l` -lt 2 ]; then
	echo "Could not find two(read/write) LCS Channels."
	ask_show_subchannels
	return 1
  fi
  echo "First 16 possible OSA / OSA-2 channel devices detected:"
  echo "chan_type is a bitfield of: CTC=1 ESCON=2 LCS=0x4"
  sort -k 2 lcs_detected | head -18 | sed 's/^0x//;s/^/ /;s/0x/  /g'
  echo 
  echo "We recommend to only use LCS autoprobing if Linux can see only two channel"
  echo "devices and you are sure that the relative adapter number 0 is not used"
  echo "by an other LPAR or Virtual Machine. For manual config, you have to enter"
  echo "the read channel device address (must be an even address). The write channel"
  echo "device number will be one greater. For autoprobing enter \"auto\"."
  AUTO_DEVNO="$DEVNO"
  [ -z "$DEVNO" -o "$DEVNO" = auto ] &&
	DEVNO=`sed -n 's/^\(0x...[02468ace]\).*/\1/p' lcs_detected | head -1`
  ANSW="yes"
  NO_ERROR="yes"
  while [ "$ANSW" = "yes" ]; do
     while true; do
	if [ "$AUTOINSTALL" = "yes" -a "$NO_ERROR" = "yes" ]
	then
		echo "Enter the read channel device number, e.g. 'FC20' (${DEVNO#0x}): $AUTO_DEVNO"
		ANSW="$AUTO_DEVNO"
	else
		readln "Enter the read channel device number, e.g. 'FC20' (${DEVNO#0x}): "
	fi
	[ -z "$ANSW" ] && ANSW=$DEVNO
	if [ "$ANSW" = "auto" -o "$ANSW" = "AUTO" -o "$ANSW" = 0 ]; then
            DEVNO=auto
	    break
	fi
        ANSW="${ANSW#0x}"
	if [ "$ANSW" != "${ANSW//[^0-9a-fA-F]/}" ]; then
            echo "Invalid character detected, allowed hex numbers only consist of 0-9,a-f."
            NO_ERROR=no
	    continue
	fi
	ANSW=0x$ANSW
	if [ $(($ANSW & 1)) -eq 1 ]; then
	    echo "Warning: You entered an odd read channel address, should be even!"
            NO_ERROR=no
	    continue
        fi
	if [ $(( $ANSW )) -ge 0 -a $(( $ANSW )) -le 65534 ]; then
            DEVNO="$ANSW"
	    break
	fi
	echo
	echo "The read channel device number should be a hex number in the range of 0-FFFE."
        NO_ERROR=no
     done
     shutdown_reset_conf_chandev
     if [ "$DEVNO" = "auto" -o "$DEVNO" = "AUTO" ]; then
	PARM=""
        CHAN=""
     else
        WRITE_DEVNO=`printf "0x%04x\n" $(($DEVNO + 1))`
        echo
        echo "Please enter the relative port number on device address ${DEVNO#0x}"
	if [ ! "$AUTOINSTALL" = "yes" -o "$NO_ERROR" = "no" ]
	then
		readln "Relative port, e.g. '0' ($PORTNO): "
		[ $ANSW ] && export PORTNO=$ANSW
	fi
        PARM="noauto=1 devno_portno_pairs=$DEVNO,$PORTNO"
	CHAN="noauto;lcs0,$DEVNO,$WRITE_DEVNO,0,$PORTNO"
	write_chandev "$CHAN"
     fi
     if grep -q lcs /proc/modules; then
        write_chandev "reprobe"
     else
  	execcmd "/sbin/insmod lcs"
     fi
     if grep lcs /proc/modules; then
       execcmd "/sbin/ifconfig $IP_DEV"
       if [ $EXIT_CODE -eq 0 ]; then
         ANSW="yes"
         echo "$IP_DEV is available, continuing with network setup."
         break
       else
         echo -e "\n$IP_DEV not available, check device addresses/cards and cables.\n"
       fi
     else
       echo -e "\nlcs module not loaded,  check device addresses/cards and cables.\n"
     fi
     yes_no "Do you want to retry the setup of the lcs module (Yes/No) ? "
     NO_ERROR=no
  done
  if [ "$ANSW" = "no" ]; then
     shutdown_reset_conf_chandev
     false
  fi
}
#
#
# ask for lcs parameters for OSA devices, checks for chandev and calls load_LCS_chandev then
#
function load_LCS () {
  if [ -f /proc/chandev ]; then
	load_LCS_chandev
	return
  fi
  display_license || return 0
  ANSW="yes"
  NO_ERROR="yes"
  while [ "$ANSW" = "yes" ]; do
        echo "Please enter the device address of the network device"
        echo "Ask your system administrator for the correct settings."
        echo "If there is only _ONE_ OSA network device attached to your machine,"
        echo "you may type \"auto\" for automatic detection; use this option carefully."
	AUTO_DEVNO="$DEVNO"
	if [ "$AUTOINSTALL" = "yes" -a "$NO_ERROR" = "yes" ]
	then
		echo "Network device address, e.g. 'FC20' ($DEVNO): $AUTO_DEVNO"
		ANSW=$AUTO_DEVNO
	else
		readln "Network device address, e.g. 'FC20' ($DEVNO): "
	fi
	[ $ANSW ] && export DEVNO=$ANSW
        if [ "$DEVNO" = "auto" -o "$DEVNO" = "AUTO" ]; then
          PARM=""
        else
          echo
          echo "Please enter the relative port number on device address $DEVNO"
	  if [ "$AUTOINSTALL" = "yes" -a "$NO_ERROR" = "yes" ]
	  then
		echo "Relative port, e.g. '0' ($PORTNO): $PORTNO"
		ANSW=$PORTNO
	  else
		  readln "Relative port, e.g. '0' ($PORTNO): "
	  fi
          [ $ANSW ] && export PORTNO=$ANSW
          PARM="noauto=1 devno_portno_pairs=0x$DEVNO,$PORTNO"
          WRITE_DEVNO=`printf "%0x\n" $(($DEVNO + 1))`
	  CHAN="noauto;lcs0,0x$DEVNO,0x$WRITE_DEVNO,0,$PORTNO"
        fi
        echo
        if grep lcs /proc/modules; then
	  echo "Unloading LCS module..."
          execcmd "/sbin/rmmod lcs"
        fi
        echo "Trying to start the LCS module now..."
        echo "insmod lcs $PARM :"
        execcmd "/sbin/insmod lcs $PARM"
        if grep lcs /proc/modules; then
          execcmd "/sbin/ifconfig $IP_DEV"
          if [ $EXIT_CODE -eq 0 ]; then
            if [ "$PARM" = "" ]; then
		echo "Ensure that the device you want to use is detected as $IP_DEV"
		echo "(check the lines beginning with \"lcs:\")."
	    fi
            ANSW="yes"
            break
          else
            echo -e "\n$IP_DEV not available, check device addresses/cards.\n"
          fi
        else
          echo -e "\nlcs module not loaded, check device addresses/cards.\n"
        fi
        yes_no "Do you want to retry the setup of the lcs module (Yes/No) ? "
	NO_ERROR=no
  done
  if [ "$ANSW" = "yes" ]; then
     echo "$IP_DEV is available, continuing with network setup."
  else
     false
  fi
}
#
#
# load the qeth driver
#
function load_QETH () {
  if ! grep qdio /proc/modules; then
    echo "Loading qdio..."
    execcmd "/sbin/insmod qdio"
  fi
  if [ "$NETSELECT" = hsi ]; then
    CUTYPE=05
    NETTYPE=Hipersocket
  else
    CUTYPE=01
    NETTYPE='OSA Express or Gigabit Ethernet'
  fi
  sed -n '1,/^channels detected/d;/^0x/p;/^ driver/q' /proc/chandev > chandet
  sed 's/^0x.... 0x//;s/ *0x/ /g;s/ [ny].*//;s/  */ /g' chandet >chandet.fmt
  sed -n "s/10 1731 $CUTYPE 1732 $CUTYPE .. //p" chandet.fmt > chandet.qeth
  NUMCHANS=`wc -l <chandet.qeth`
  echo $NUMCHANS "$NETTYPE Channels were detected."
  if [ $NUMCHANS -lt 3 ]; then
    echo "3 $NETTYPE Channels need to be detected to use $NETSELECT."
    ask_show_subchannels
    return 1
  fi
  if [ "$NETSELECT" = qeth ]; then
    grep '^...[02468ace] ' chandet.qeth >qeth_read_chans
    if [ ! -s qeth_read_chans ]; then
      echo "One even device address for OSA/QDIO Read Channel needs to exist!"
      ask_show_subchannels
      return 1
    fi
  fi
  display_license || return 0
  if [ $NUMCHANS -gt 20 ]; then
    echo "Summary of all $NETTYPE channels detected:"
    echo "Device Addresses CHPID(s)"
    sed 's/^\(...\)./            \1?/;s/0* *$//g' chandet.qeth | sort -u +1
  fi
  echo "First $NETTYPE Channels that were detected:"
  echo "Device Addresses CHPID(s)"
  sed 's/^\(....\)/            \1/;s/0* *$//g' chandet.qeth|head -20

  if [ "$DEVNO" != auto -a "$DEVNO" != "${DEVNO//[^0-9a-fA-F]/}" ]; then
    echo "Device address $DEVNO contains non-hexadecimal characters, ignoring it."
    DEVNO=auto
  fi
  if [ "$DEVNO2" != auto -a "$DEVNO2" != "${DEVNO2//[^0-9a-fA-F]/}" ]; then
    echo "Device address $DEVNO2 contains non-hexadecimal characters, ignoring it."
    DEVNO2=auto
  fi
  if [ "$DEVNO3" != auto -a "$DEVNO3" != "${DEVNO3//[^0-9a-fA-F]/}" ]; then
    echo "Device address $DEVNO3 contains non-hexadecimal characters, ignoring it."
    DEVNO3=auto
  fi
  if [ "$DEVNO" != auto ]; then
    [[ "$DEVNO" == 0x* ]] || DEVNO=0x$DEVNO
    DEVNO=`printf %04x $DEVNO`
    grep -q "^${DEVNO} " chandet.qeth || {
      echo "Device address ${DEVNO#0x} not found, ignoring it."
      DEVNO=auto
    }
  fi
  if [ "$DEVNO2" != auto ]; then
    [[ "$DEVNO2" == 0x* ]] || DEVNO2=0x$DEVNO2
    DEVNO2=`printf %04x $DEVNO2`
    grep -q "^${DEVNO2} " chandet.qeth || {
      echo "Device address ${DEVNO2#0x} not found, ignoring it."
      DEVNO2=auto
    }
  fi
  if [ "$DEVNO3" != auto ]; then
    [[ "$DEVNO3" == 0x* ]] || DEVNO3=0x$DEVNO3
    DEVNO3=`printf %04x $DEVNO3`
    grep -q "^${DEVNO3} " chandet.qeth || {
      echo "Device address ${DEVNO3#0x} not found, ignoring it."
      DEVNO3=auto
    }
  fi
  if [ "$NETSELECT" = qeth ]; then
    echo
    echo "Format for OSA Express configuration: Read Channel,Write Channel,Data Channel"
    echo "The Read Channel must be an even device address,"
    echo "The Write Channel must be the Read Channel address plus 1,"
    echo "The Data Channel may be any OSA channel of the same Card."
    echo
    if [ $DEVNO != auto ] && [[ $DEVNO != ???[02468ace] ]]; then
      echo "Device address ${DEVNO} is not even, ignoring it."
      DEVNO=auto
    fi
    if [ $DEVNO2 != auto -a $DEVNO = auto ] && [[ $DEVNO2 == ???[13579bdf] ]]; then
      DEVNO=`printf %04x $(( 0x$DEVNO2 - 1 ))`
    fi
    while [ -s qeth_read_chans ]; do
      if [ "$DEVNO" != auto ]; then
        DEVNO1=$DEVNO
        DEVNO=auto
      else
        DEVNO1=`sed -n 's/^\(....\) .*/\1/p' qeth_read_chans | head -1`
      fi
      DEVNO2=`printf %04x $(( 0x$DEVNO1 + 1 ))`
      if grep -q "^${DEVNO2} " chandet.qeth; then
	CHPIDlist=`sed -n "s/^${DEVNO2} \([0-9a-f]*\) */\1/p" chandet.qeth`
	grep "${CHPIDlist}" chandet.qeth |
		grep -v -e "^${DEVNO1} " -e "^${DEVNO2} " > qeth_data_chans
        if [ "$DEVNO3" != auto ] && grep -q "^${DEVNO3} " qeth_data_chans; then
          DEVNO=$DEVNO1
          break
        fi
	DEVNO3=`sed -n 's/^\(....\) .*/\1/p' qeth_data_chans | head -1`
	if [ "$DEVNO3" ]; then
          DEVNO=$DEVNO1
	  break
	else
	  echo "No Data Channel address detected!"
	  ask_show_subchannels
	  return 1
	fi
      else
	mv qeth_read_chans qeth_read_chans.old
	grep -v "^$DEVNO1 " qeth_read_chans.old > qeth_read_chans
      fi
    done
    if [ "$DEVNO" = auto ]; then
      echo "No address for Read Channel with matching address for Write Channel detected!"
      ask_show_subchannels
      return 1
    fi
  else
    cp chandet.qeth chandet.hsi
    while [ -s chandet.hsi ]; do
      if [ "$DEVNO" != auto ]; then
        DEVNO1=$DEVNO
        DEVNO=auto
      else
        DEVNO1=`sed -n 's/^\(....\) .*/\1/p' chandet.hsi | head -1`
      fi
      CHPIDlist=`sed -n "s/^${DEVNO1} \([0-9a-f]*\) */\1/p" chandet.hsi`
      if [ "$DEVNO2" != auto ]; then
	grep -q -e "^${DEVNO2} ${CHPIDlist}" chandet.hsi || DEVNO2=auto
      fi
      if [ "$DEVNO2" = auto ]; then
        DEVNO2=`grep "${CHPIDlist}" chandet.hsi | grep -v "^${DEVNO1} "|head -1|sed -n 's/^\(....\) .*/\1/p'`
      fi
      if [ -z ${DEVNO2} ]; then
	mv chandet.hsi chandet.hsi.old
	grep -v "${CHPIDlist}" chandet.hsi.old > chandet.hsi
	continue
      fi
      if [ "$DEVNO3" != auto ]; then
	grep -q -e "^${DEVNO3} ${CHPIDlist}" chandet.hsi || DEVNO3=auto
      fi
      if [ "$DEVNO3" = auto ]; then
        DEVNO3=`grep "${CHPIDlist}" chandet.hsi |
		grep -v -e "^${DEVNO1} " -e "^${DEVNO2} "|head -1 |sed -n 's/^\(....\) .*/\1/p'`
      fi
      if [ -z ${DEVNO3} ]; then
	mv chandet.hsi chandet.hsi.old
	grep -v "${CHPIDlist}" chandet.hsi.old > chandet.hsi
	continue
      fi
      DEVNO=${DEVNO1}
      break
    done
    if [ "$DEVNO" = auto ]; then
      echo "Could not find 3 channels from the same CHPID!"
      ask_show_subchannels
      return 1
    fi
  fi
  echo "Possible configuration: read: 0x$DEVNO, write: 0x$DEVNO2, data: 0x$DEVNO3"
  DEVNOS=0x${DEVNO/auto/f801},0x${DEVNO2/auto/f802},0x${DEVNO3/auto/f803}
  DEVNOs="$DEVNOS"
  ANSW="yes"
  NO_ERROR="yes"
  while [ "$ANSW" = "yes" ]; do
     while true; do
	echo "Enter the device addresses for the qeth module, e.g. '$DEVNOs'"
	if [ "$AUTOINSTALL" = "yes" -a "$NO_ERROR" = "yes" ]
	then
		WRITE_DEVNO=`printf %04x $(( 0x$READ_DEVNO + 1 ))`
		ANSW="0x$READ_DEVNO,0x$WRITE_DEVNO,0x$DATA_DEVNO"
	else
		if [ -n "$READ_DEVNO" -a -n "$DATA_DEVNO" ]
		then
			WRITE_DEVNO=`printf %04x $(( 0x$READ_DEVNO + 1 ))`
			DEVNOS="0x$READ_DEVNO,0x$WRITE_DEVNO,0x$DATA_DEVNO"
		fi
		readln "($DEVNOS): "
		[ -z "$ANSW" ] && ANSW="$DEVNOS"
	fi
       DEVNOS=`echo "$ANSW"|check_qeth_channels` && break
       NO_ERROR=no
     done
     CHAN=""
     [ "$DEVNOS" != auto ] && CHAN="noauto;qeth0,$DEVNOS"
     if [ "$NETSELECT" = qeth -a "${DEVNOS/*,portname:*/}" ]; then
	NO_ERROR="yes"
        while true; do
	    if [ "$AUTOINSTALL" = "yes" ]
	    then
		ANSW="$PORTNAME"
	    else
		readln "Please enter the portname(case sensitive) to use($PORTNAME): "
	    fi
	    if [ ${#ANSW} -eq 0 ]; then
		echo "Warning: Only old MCLs allow empty portnames. Because not"
		echo "every operator may be aware of this config when updating"
		echo "the MCL, you may loose network as soon as it's updated."
		yes_no "Are you sure that you want to use an empty portname (Yes/No) ? "
		[ "$ANSW" != "yes" ] && continue
		ANSW=
	    fi
	    if [ ${#ANSW} -le 8 ]; then
		[ ${ANSW} ] && PORTNAME="${ANSW}"
		break
	    fi
            echo "The portname may not consist of more than 8 characters."
	    NO_ERROR=no
        done
        if [ "$PORTNAME" ]; then
          if [ "$DEVNOS" = auto ]; then
	    CHAN="$CHAN;add_parms,0x10,portname:$PORTNAME"
          else
	    for range in `echo "$DEVNOS"|print_qeth_ranges`; do
	      CHAN="$CHAN;add_parms,0x10,$range,portname:$PORTNAME"
	    done
          fi
        fi
     fi
     write_chandev "reset_conf"
     [ "$CHAN" ] && write_chandev "$CHAN"
     PARM="qeth_options=$DEVNOS"
     [ "$PORTNAME" ] && PARM="$PARM,portname:$PORTNAME"
     if grep -q qeth /proc/modules; then
        write_chandev "reprobe"
     else
  	execcmd "/sbin/modprobe qeth"
     fi
     if grep qeth /proc/modules; then
       for i in 2 1 2 3 4 5 6 7 8 9; do
	 sleep $i
         if [ -s /hotplug.msg ]; then
	   if grep -q "^start $IP_DEV" /hotplug.msg; then
             echo "$IP_DEV detected!"
	     break
           elif grep -q '^start ' /hotplug.msg; then
	     read a dev < /hotplug.msg
             echo "$dev detected, expected $IP_DEV, aborting."
             write_chandev "reset_conf"
             return 1
           fi
         fi
       done
       execcmd "/sbin/ifconfig $IP_DEV"
       if [ $EXIT_CODE -eq 0 ]; then
         ANSW="yes"
         break
       else
         echo -e "\n$IP_DEV not available, check device addresses/cards.\n"
       fi
     else
       echo -e "\nqeth module not loaded, module problem.\n"
     fi
     yes_no "Do you want to retry the qeth-setup (Yes/No) ? "
     NO_ERROR=no
  done
  if [ "$ANSW" = "yes" ]; then
     echo "$IP_DEV is available, continuing with network setup."
  else
     write_chandev "reset_conf"
     return 1
  fi
}
#
#
# load the ctc driver
#
function load_CTC_chandev () {
  if [ "$NETSELECT" = escon ]; then
    NETTYPE=ESCON
    OTHERTYPE=CTC
  else
    NETTYPE=CTC
    OTHERTYPE=ESCON
  fi
  sed -n '1,/^channels detected/d;s/0x/  /g;
	s/  01    3088/CTC         /p;
	s/  02    3088/ESCON       /p;
	s/  05    3088/CTC or LCS  /p;
	s/  06    3088/ESCON or LCS/p;' /proc/chandev | grep -v "$OTHERTYPE" |
		cut -c 10-28,53-68 | sort >ctc_detected
  if [ `grep '^[0-9a-f]' ctc_detected | wc -l` -lt 2 ]; then
	echo "Couldn't find two $NETTYPE Channels (read and write)."
	ask_show_subchannels
	return 1
  fi
  echo "List of first 10 $NETTYPE Channels that were detected:"
  echo "Dev. Channel type  CHPIDS"
  head -10 ctc_detected
  ANSW="yes"
  NO_ERROR=yes
  while [ "$ANSW" = "yes" ]; do
	[ -z "$DEVNO" -o "$DEVNO" = auto ] &&
           DEVNO=`cut -d' ' -f 1 ctc_detected | head -1`
        LAST_DEVNO="$DEVNO"
	if [ "$AUTOINSTALL" = "yes" -a "$NO_ERROR" = "yes" ]
	then
		echo "Device address for read channel ($DEVNO): $READ_DEVNO"
		ANSW=$READ_DEVNO
	else
		[ -n "$READ_DEVNO" ] && DEVNO=$READ_DEVNO
		readln "Device address for read channel ($DEVNO): "
	fi
	[ $ANSW ] && export DEVNO=$ANSW
        DEVNO="000$DEVNO"
	DEVNO=${DEVNO:${#DEVNO}-4:4}
	grep "^$DEVNO " ctc_detected >ctc_DEVNO
	[ -s ctc_DEVNO ] || echo "Warning: $DEVNO is not a detected $NETTYPE channel"
	[ "$LAST_DEVNO" = "$DEVNO" ] || DEVNO2=`echo | sed -n "1,/$DEVNO /d;s/^\(....\).*/\1/p;q" - ctc_detected`
	[ -z "$DEVNO2" -o "$DEVNO2" = auto ] && DEVNO2=`cut -d' ' -f 1 ctc_detected | head -2|tail -1`
	if [ "$AUTOINSTALL" = "yes" -a "$NO_ERROR" = "yes" ]
	then
		echo "Device address for write channel ($DEVNO2): $WRITE_DEVNO"
		ANSW=$WRITE_DEVNO
	else
		[ -n "$WRITE_EVNO" ] && DEVNO2=$WRITE_DEVNO
		readln "Device address for write channel ($DEVNO2): "
	fi
	[ $ANSW ] && export DEVNO2=$ANSW
        DEVNO2="000$DEVNO2"
	DEVNO2=${DEVNO2:${#DEVNO2}-4:4}
	grep "^$DEVNO2 " ctc_detected >ctc_DEVNO2
	[ -s ctc_DEVNO2 ] || echo "Warning: $DEVNO2 is not a detected $NETTYPE channel"
        ask_select_protocol
        PARM="ctc=$IP_DEV:0x$DEVNO:0x$DEVNO2:$PROTOCOL"
        CHAN="$IP_DEV,0x$DEVNO,0x$DEVNO2,0,$PROTOCOL"
	write_chandev "$CHAN"
	if grep -q ctc /proc/modules; then
	    if [ -d /proc/net/ctc ]; then
		echo "Stopping ctc driver..."
		ls -A /proc/net/ctc >ctc_devs
		if [ -s ctc_devs ]; then
		    for dev in `cat ctc_devs`; do
			echo "Shutting $dev down..."
			execcmd "ifconfig $dev down"
		    done
		fi
	    fi
	    execcmd "/sbin/rmmod ctc"
            write_chandev "reprobe"
	fi
	echo "Starting ctc driver:"
	execcmd "/sbin/modprobe ctc"
        if grep ctc /proc/modules; then
          for i in 1 2 3 4 5 6 7; do
	    sleep $i
            if [ -s /hotplug.msg ]; then
	      if grep -q '^start ' /hotplug.msg; then
	        read an IP_DEV < /hotplug.msg
                echo "$IP_DEV detected."
                break
              fi
            fi
          done
          execcmd "/sbin/ifconfig $IP_DEV" >/dev/null
          if [ $EXIT_CODE -eq 0 ]; then
            ANSW="yes"
            break
          else
            echo -e "\n$IP_DEV not available, check device addresses.\n"
          fi
        else
          echo -e "\nctc module not loaded, module problem.\n"
        fi
        yes_no "Do you want to retry to configure $IP_DEV (Yes/No) ? "
	NO_ERROR=no
  done
  if [ "$ANSW" = "yes" ]; then
     echo "$IP_DEV is available, continuing with network setup."
  else
     write_chandev "reset_conf"
     false
  fi
}
#
#
# load the ctc driver
#
function load_CTC () {
  if [ -f /proc/chandev ]; then
	load_CTC_chandev
	return
  fi
  ANSW="yes"
  NO_ERROR=yes
  while [ "$ANSW" = "yes" ]; do
        if grep ctc /proc/modules; then
          echo "Unloading the ctc driver..."
          execcmd "/sbin/rmmod ctc"
        fi
        echo "Please enter the options for the CTC device driver now."
	echo "Specify which channel addresses Linux should use (recommeded)"
        echo "or enter 'auto' to autosense all available channel devices,"
	echo "but be careful if you share channel devices!"
	echo "ctc options:"
	if [ "$AUTOINSTALL" = "yes" -a "$NO_ERROR" = "yes" ]
	then
		echo "Device address for read channel, e.g. '40A' ($DEVNO): $READ_DEVNO"
		ANSW=$READ_DEVNO
	else
		[ -n "$READ_DEVNO" ] && DEVNO=$READ_DEVNO
		readln "Device address for read channel, e.g. '40A' ($DEVNO): "
	fi
	[ $ANSW ] && export DEVNO=$ANSW
        if [ "$DEVNO" = "auto" -o "$DEVNO" = "AUTO" ]; then
          PARM=""
        else
	  if [ "$AUTOINSTALL" = "yes" -a "$NO_ERROR" = "yes" ]
	  then
		echo "Device address for write channel, e.g. '40B' ($DEVNO2): $WRITE_DEVNO"
		ANSW=$WRITE_DEVNO
	  else
		[ -n "$WRITE_DEVNO" ] && DEVNO2=$WRITE_DEVNO
		readln "Device address for write channel, e.g. '40B' ($DEVNO2): "
	  fi
	  [ $ANSW ] &&  export DEVNO2=$ANSW
	  echo "The network device name used will be: $IP_DEV"
          PARM="setup='\"ctc=0,0x$DEVNO,0x$DEVNO2,$IP_DEV\"'"
        fi
        echo "Trying to start the ctc module now..."
        echo "modprobe ctc $PARM :"
        execcmd "/sbin/modprobe ctc $PARM"
        if grep ctc /proc/modules; then
          execcmd "/sbin/ifconfig $IP_DEV"
          if [ $EXIT_CODE -eq 0 ]; then
            ANSW="yes"
            break
          else
            echo -e "\n$IP_DEV not available, check device addresses.\n"
          fi
        else
          echo -e "\nctc module not loaded, check device addresses.\n"
        fi
        yes_no "Do you want to retry the load of ctc (Yes/No) ? "
	NO_ERROR=no
  done
  if [ "$ANSW" = "yes" ]; then
     echo "$IP_DEV is available, continuing with network setup."
  else
     false
  fi
}
#
#
# load the iucv driver
#
function load_IUCV () {
  ANSW="yes"
  NO_ERROR="yes"
  while [ "$ANSW" = "yes" ]; do
    echo "Please enter the name(userid) of the target VM guest here."
    echo "In VIF this is normally \$TCPIP, in VM normally TCPIP."
    echo ""
    if [ "$AUTOINSTALL" = "yes" -a "$NO_ERROR" = "yes" ]
    then
	echo "The name of the peer guest, e.g. 'TCPIP' ($PEER): $AUTO_PEER"
	ANSW=$AUTO_PEER
    else
	[ -n "$AUTO_PEER" ] && PEER=$AUTO_PEER
	readln "The name of the peer guest, e.g. 'TCPIP' ($PEER): "
    fi
    [ "$ANSW" ] && export PEER=$ANSW
    [ "$PEER" ] && PARM="iucv='$PEER'"
    if grep netiucv /proc/modules; then
      echo "Unloading netiucv module..."
      execcmd "/sbin/rmmod netiucv"
    fi
    echo "Trying to start the netiucv module now..."
    echo "modprobe netiucv $PARM :"
    execcmd "/sbin/modprobe netiucv $PARM"
    if grep netiucv /proc/modules; then
      echo "netiucv module is loaded, checking interface $IP_DEV."
      execcmd "/sbin/ifconfig $IP_DEV"
      if [ $EXIT_CODE -eq 0 ]; then
        ANSW="yes"
        break
      else
        echo "Error: $IP_DEV is not available, likely a problem connecting to the target."
      fi
    else
      echo "Error: The netiucv module is NOT loaded."
    fi
    yes_no "Do you want to retry the setup of IUCV (Yes/No) ? "
    NO_ERROR=no
  done
  if [ "$ANSW" = "yes" ]; then
     echo "$IP_DEV seems to exist, continuing with network setup."
  else
     false
  fi
}
#
#
# load the UTS c7000 driver (Kernel 2.2 only)
#
function load_C7000 () {
  echo "The C7000 driver from UTS is used for Cisco channel attached routers."
  echo "It is not provided by IBM, in case of problems, please contact SuSE."
  ANSW="yes"
  while [ "$ANSW" = "yes" ]; do
        echo "Please enter the options for the C7000 device driver now."
        echo "You can let the base address be autodetected by entering 'auto'."
	echo "If you are not sure what to enter please ask your system administrator."
	echo ""
	echo "c7000 options:"
        readln "Base unit address of the channel attached router, e.g. '336C' ($DEVNO): "
	[ $ANSW ] && export DEVNO=$ANSW
        if [ "$DEVNO" = "auto" -o "$DEVNO" = "AUTO" ]; then
          PARM=""
        else
          PARM="base0=0x$DEVNO noauto=1"
	fi
#
	echo   "Local host name        - claw directive 'host-name' (first string)"
	readln "default: 'UTS' ($LHOST): "
	[ $ANSW ] && export LHOST=$ANSW
	[ $LHOST ] && PARM="$PARM lhost0=\"$LHOST\""
#
	echo   "Unit name              - claw directive 'device-name' (second string)"
	readln "default: 'C7011' ($UHOST): "
	[ $ANSW ] && export UHOST=$ANSW
	[ $UHOST ] && PARM="$PARM uhost0=\"$UHOST\""
#
	echo   "Local application name - claw directive 'host-app' (third string)"
	readln "default: 'TCPIP' ($LAPPL): "
	[ $ANSW ] && export LAPPL=$ANSW
	[ $LAPPL ] && PARM="$PARM lappl0=\"$LAPPL\""
#
	echo   "Unit application name  - claw directive 'device-app' (fourth string)"
	readln "default: 'TCPIP' ($UAPPL): "
	[ $ANSW ] && export UAPPL=$ANSW
	[ $UAPPL ] && PARM="$PARM uappl0=\"$UAPPL\""
#
	echo   "Message level - higher numbers will result in additional diagnostic messages"
	readln "default: '0' ($DBG): "
	[ $ANSW ] && export DBG=$ANSW
	[ $DBG ] && PARM="$PARM dbg=$DBG"
#
        echo "The network device name used will be: $IP_DEV"
	if grep c7000 /proc/modules; then
          echo "Unloading c7000 module..."
          execcmd "/sbin/rmmod c7000"
	fi
        echo "Trying to start the c7000 module now..."
        echo "insmod c7000 $PARM :"
        execcmd "/sbin/insmod c7000 $PARM"
        echo
        if grep c7000 /proc/modules; then
          echo "c7000 module is loaded, checking interface $IP_DEV."
          execcmd "/sbin/ifconfig $IP_DEV"
          if [ $EXIT_CODE -eq 0 ]; then
            ANSW="yes"
            break
          else
            echo "Error: $IP_DEV is not available, must be a setup or comm problem."
          fi
        else
          echo "Error: The c7000 module is NOT loaded."
        fi
        yes_no "Do you want to retry the setup of c7000 (Yes/No) ? "
  done
  if [ "$ANSW" = "yes" ]; then
     echo "$IP_DEV seems to exist, continuing with network setup."
  else
     false
  fi
}
#
#
# checks an IP to have numbers only between 0 and 255:
#
# example:
# if echo $IP_ADDR | check_ip; then ...
#
function check_ip()
{
        IFS=". " read ip1 ip2 ip3 ip4 rest
        for i in ip1 ip2 ip3 ip4
        do
                eval x=\$$i
                if [ $x -lt 0 -o $x -gt 255 ]; then
                        echo "$x: Value must be between 0 and 255"
                        return 1
                fi
        done
        return 0
}
#
#
# calculates the broadcast address; parameters are IP_ADDR and IP_NETMASK
#
function calc_broadcast_enh()
#
# STDIN: IP, NETMASK
# STDOUT: BROADCAST
{
        IFS=". " read ip1 ip2 ip3 ip4  nm1 nm2 nm3 nm4 rest
        echo $(( ($ip1 & $nm1 | ~$nm1) & 255)).$(( ($ip2 & $nm2 | ~$nm2) & 255)).$(( ($ip3 & $nm3 | ~$nm3) & 255)).$((($ip4 & $nm4 | ~$nm4) & 255))
}
#
#
# MAIN
#
#
#
# If we are not started by init (we are linuxrc), we have to make sure
# that we have an suitable PATH for us and the user:
#
PATH=/sbin:/bin:/usr/sbin:/usr/bin
#
#
# Ensure that we have /proc mounted:
#
[ ! -f /proc/version ] && mount -t proc virtual-proc-filesystem /proc
#
#
# We want to save the kernel message ring buffer to a file:
#
[ ! -e /boot.msg ] && dmesg > /boot.msg
#
# set debug to yes/no
#set -vx
: ${DEBUG:=no}
#
if [ "$DEBUG" = "no" ]
then
	INSTALLINF="/etc/netsetup.inf"
else
	INSTALLINF="./netsetup.inf"
fi
#
if [ "$DEBUG" = "no" ]; then
	if [ -e /linuxrc.init ]; then
		. /linuxrc.init
		rm /linuxrc.init
#
#		We use the initenv from the kernel parmfile only in the first run
#
		for i in 1 2 3 4 5 6 7 8 9
		do
			eval LINUXRC_READLINE="\$LINUXRC_READ$i"
			if [ "$LINUXRC_READLINE" ]; then
				LINUXRC_READ="$LINUXRC_READ $LINUXRC_READLINE"
			fi
		done
		if [ "$LINUXRC_READ" ]; then
			LINUXRC_READ="`echo $LINUXRC_READ|sed 's/\"//g'`"
			echo "Found this input script for linuxrc: $LINUXRC_READ"
		fi
	fi
else
	if [ -e ./linuxrc.init.debug ]; then
		. ./linuxrc.init.debug
		rm ./linuxrc.init.debug
	fi
#	export -p
fi
#
echo "\
=                                                                   =
==-    Welcome to SuSE Linux Enterprise Server 8 for zSeries      -==
=                                                                   ="
[ "$DEBUG" = "yes" ] && echo -e "\n- Running in DEBUG mode. -\n"
EXIT_SCRIPT=0
CONFIG_IS_OK=0
while [ $CONFIG_IS_OK = 0 ]; do
  select_network_device_type
  [ $CONFIG_IS_OK = 1 -o $EXIT_SCRIPT = 1 ] && break
  echo
  if [ "$AUTOINSTALL" = "yes" ]
  then
	  echo "Please enter your full host name, e.g. 'linux.example.com' ($IP_HOST): $IP_HOST"
	  echo "Please enter your IP address, e.g. '192.168.0.1' ($IP_ADDR): $IP_ADDR"
	  export IP_ADDR IP_HOST
  else
	  readln "Please enter your full host name, e.g. 'linux.example.com' ($IP_HOST): "
	  [ $ANSW ] && export IP_HOST=$ANSW
	  readln "Please enter your IP address, e.g. '192.168.0.1' ($IP_ADDR): "
	  [ $ANSW ] && export IP_ADDR=$ANSW
  fi
  case "$NETSELECT" in
    tr|eth|qeth|hsi|c7000)
	    if [ "$AUTOINSTALL" = "yes" ]
	    then
		    echo "Please enter the net mask, e.g. '255.255.255.0' ($IP_NETMASK): $IP_NETMASK"
		    IP_BROADCAST=$(echo $IP_ADDR $IP_NETMASK | calc_broadcast_enh)
		    echo "Please enter the broadcast address if different from ($IP_BROADCAST): $IP_BROADCAST"
		    echo "Please enter the gateway's IP address, e.g. '192.168.0.254' ($IP_GATEWAY): $IP_GATEWAY"
		    export IP_NETMASK IP_BROADCAST IP_GATEWAY
	    else
		    readln "Please enter the net mask, e.g. '255.255.255.0' ($IP_NETMASK): "
		    [ $ANSW ] && export IP_NETMASK=$ANSW
		    IP_BROADCAST=$(echo $IP_ADDR $IP_NETMASK | calc_broadcast_enh)
		    readln "Please enter the broadcast address if different from ($IP_BROADCAST): "
		    [ $ANSW ] && export IP_BROADCAST=$ANSW
		    readln "Please enter the gateway's IP address, e.g. '192.168.0.254' ($IP_GATEWAY): "
		    [ $ANSW ] && export IP_GATEWAY=$ANSW
	    fi
	    ;;
#    peer-to-peer networks
    ctc|escon|iucv)
	    if [ "$AUTOINSTALL" = "yes" ]
	    then
		    echo "Please enter the IP address of your peer, e.g. '192.168.0.254' ($IP_PEER): $IP_PEER"
		    export IP_PEER
	    else
		    readln "Please enter the IP address of your peer, e.g. '192.168.0.254' ($IP_PEER): "
		    [ $ANSW ] && export IP_PEER=$ANSW
	    fi
	    export IP_GATEWAY=$IP_PEER
	    export IP_NETMASK=255.255.255.255
	    ;;
    *)
	    echo "Something went wrong with $NETSELECT..."
  esac
  if [ "$AUTOINSTALL" = "yes" ]
  then
	  echo "Please enter the IP address of the DNS server or 'none' for no DNS ($IP_DNS): $IP_DNS"
	  export IP_DNS
  else
	  readln "Please enter the IP address of the DNS server or 'none' for no DNS ($IP_DNS): "
	  [ $ANSW ] && export IP_DNS=$ANSW
  fi
  [ "$IP_DNS" = "none" -o "$IP_DNS" = "NONE" ] && export IP_DNS=""
  if [ "$IP_DNS" ]; then
    [ -z "$IP_SEARCH" ] && IP_SEARCH=${IP_HOST#*.}
    if [ "$AUTOINSTALL" = "yes" ]
    then
	    echo "Please enter the DNS search domain, e.g. 'example.com' ($IP_SEARCH): $IP_SEARCH"
	    export IP_SEARCH
    else
	    readln "Please enter the DNS search domain, e.g. 'example.com' ($IP_SEARCH): "
	    [ $ANSW ] && export IP_SEARCH=$ANSW
    fi
  else
    IP_SEARCH=none
  fi
  [ "$IP_SEARCH" = "none" -o "$IP_SEARCH" = "NONE" ] &&  export IP_SEARCH=""
  while true; do
    if [ "$IP_MTU" = "default" ]; then
      case "$NETSELECT" in
	tr|eth)
	    export IP_MTU=1492
	    ;;
	ctc|qeth|iucv|c7000)
	    export IP_MTU=1500
	    ;;
        escon)
	    export IP_MTU=32760
	    ;;
        hsi)
            # Do not set mtu, hipersocket should use IOCDS/Channel default
	    export IP_MTU="max. Socket MTU"
	    ;;
	*)
	    echo "Something went wrong with $NETSELECT..."
      esac
    fi
    if [ "$AUTOINSTALL" = "yes" ]
    then
	    echo "Please enter the MTU (Maximum Transfer Unit),"
	    echo "leave blank for default: ($IP_MTU): $IP_MTU"
	    ANSW=$IP_MTU
    else
	    echo "Please enter the MTU (Maximum Transfer Unit),"
	    readln "leave blank for default: ($IP_MTU): "
    fi
    echo
    [ $ANSW ] && export IP_MTU=$ANSW
    [ $(( ${IP_MTU//[A-z]*/} + 0 )) -eq 0 ] && IP_MTU=0
    case "$NETSELECT" in
      ctc|escon|iucv)
        [ $IP_MTU -ge 576 -a $IP_MTU -le 32768 -o $IP_MTU = 0 ] && break
	echo "For the CTC/IUCV driver, the MTU must be in the range 576-32768."
        ;;
      tr|eth)
    	[ $IP_MTU -ge  68 -a $IP_MTU -le 1500 -o $IP_MTU = 0 ] && break
	echo "For the LCS driver, the MTU must be in the range 68-1500."
        ;;
      c7000|qeth)
    	[ $IP_MTU -ge 576 -a $IP_MTU -le 1500 -o $IP_MTU = 0 ] && break
	echo "The installation MTU range for qeth/c7000 is 576-1500, set other values later."
	;;
      hsi)
	break
	;;
    esac
    IP_MTU=default
  done
  echo "Configuration for $IP_DEV will be:"
  [ $IP_HOST ] && echo "Full host name   : $IP_HOST"
  echo "IP address       : $IP_ADDR"
  case "$NETSELECT" in
    tr|eth|qeth|hsi|c7000)
	    echo "Net mask         : $IP_NETMASK"
	    [ "$IP_BROADCAST" ] && echo "Broadcast address: $IP_BROADCAST"
	    [ "$IP_GATEWAY" ] && echo "Gateway address  : $IP_GATEWAY"
	    ;;
    ctc|escon|iucv)
	    echo "Peer IP address  : $IP_PEER"
	    ;;
    *)
	    echo "Something went wrong with $NETSELECT..."
  esac
  [ "$IP_DNS" ] && echo "DNS IP address   : $IP_DNS"
  [ "$IP_SEARCH" ] && echo "DNS search domain: $IP_SEARCH"
  if test $IP_MTU ; then
    if [ $IP_MTU != 0 ]; then
      echo "MTU size         : $IP_MTU"
    else
      echo "MTU size         : default interface MTU"
    fi
  fi
  if [ "$AUTOINSTALL" = "yes" ]
  then
	  echo "Is this correct (Yes/No) ? yes"
	  ANSW="yes"
  else
	  yes_no "Is this correct (Yes/No) ? "
  fi
  if [ "$ANSW" = "yes" ]; then
    change_passwd
    activate_config
    CONFIG_IS_OK=1
  fi
done
[ $EXIT_SCRIPT = 0 ] && run_services
#
[ "$LINUXRC_RECORD" ] && echo "LINUXRC_READ=\"$LINUXRC_READ\""
check_memory
check_memory >> /etc/motd
