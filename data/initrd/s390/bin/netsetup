#!/bin/bash
# Copyright (c) 2000 SuSE GmbH Nuernberg, Germany.  All rights reserved.
#
# Authors: Joachim Schroeder <Joachim.Schroeder@suse.de>
#          Bernd Kaindl <Bernd.Kaindl@suse.de>
#
#	Save it for autoconfig
AUTO_PEER="$PEER"
# network setup script and linuxrc for s390-suse-linux
#
# Default environment variables:
#
# first, the network device parameters
: ${DEVNO:=auto} ${DEVNO2:=auto} ${DEVNO3:=auto} ${PORTNO:=0} ${PEER:=TCPIP}
: ${PORTNAME:=suselin7} ${PROTOCOL:=noproto}
#
#
# and export them:
export DEVNO DEVNO2 DEVNO3 PORTNAME PORTNO PEER LHOST UHOST LAPPL UAPPL DBG
#
# second, the network connection parameters
: ${IP_HOST:=linux.example.com}
: ${IP_ADDR:=192.168.0.1}
: ${IP_NETMASK:=255.255.255.0}
: ${IP_GATEWAY:=192.168.0.254}
: ${IP_PEER:=192.168.0.254}
: ${IP_DNS:=none}
# Take it from the domain of IP_HOST
#: ${IP_SEARCH:=example.com}
: ${IP_MTU:=default}
: ${SCH_ORDER:=DeviceAddr}
: ${DONTSHOW:=^....   ....  3390}
#
export IP_HOST
export IP_ADDR
export IP_NETMASK
export IP_GATEWAY
export IP_PEER
export IP_DNS
export IP_SEARCH
export IP_MTU
#
[ "$LINUXRC_RECORD" ] && LINUXRC_READ=""
#
# readln reads a line into $ANSW.
#
function readln () {
  echo -n "$1"
  if [ -z "$LINUXRC_RECORD" -a "$LINUXRC_READ" ]; then
    set -- $LINUXRC_READ
    echo "-> $1"
    ANSW=$1
    shift
    LINUXRC_READ="$@"
    [ "$ANSW" = /n -o "$ANSW" = /N ] && ANSW=""
    sleep 1
  else
    IFS='@' read ANSW || exit 1
    ANSW=`echo $ANSW | sed -e 's/^ *//'`
    if [ "$LINUXRC_RECORD" ]; then
      record_answ="$ANSW"
      [ "$record_answ" ] || record_answ=/n
      LINUXRC_READ="$LINUXRC_READ $record_answ"
    fi
    if [ "$ANSW" = "restart" -o "$ANS" = "RESTART" ]; then
	echo;echo;echo "-- Restarting linuxrc --";echo;echo
	if [ "$DEBUG" = "yes" ]; then
	    . ./linuxrc || exit 1
	else
	    . /linuxrc || exit 1
	fi
	exit 0
    fi
  fi
}
#
#
# yes_no reads either a yes or a no into $ANSW
#
function yes_no () {
  while :; do
    readln "$1"
    case "$ANSW" in
      [yY] | [yY][eE][sS]) ANSW=yes
                     break;;
      [nN] | [nN][oO])  ANSW=no
                     break;;
    esac
  done
}
#
#
# Check memory and issue a waring if we do not have a certain amount
#
function check_memory () {
	MEM=`grep MemTotal /proc/meminfo|sed 's,[^0-9]*\([0-9]*\)[^0-9]*,\1,g'`
	let MEM="($MEM >> 15) + 1 << 5" # round up to next 32M
	if [ $MEM -lt 80 ]; then
	    echo "Warning: The kernel has only $MEM MB memory for applications"
	    echo "80 MB are recommended for installation thru FTP and updating."
	fi
}
#
function ask_select_protocol() {
    NO_ERROR=yes
    while :; do
      echo "Select protocol number for $NETTYPE:"
      echo "0) Compatibility mode, also for non-Linux peers other"
      echo "   than OS/390 and z/OS (this is the default mode)"
      echo "1) Extended mode"
      echo "3) Compatibility mode with OS/390 and z/OS"
      if [ "$AUTOINSTALL" = "yes"  -a "$NO_ERROR" = "yes" ]
      then
		echo "Enter your choice ($PROTOCOL): $PROTOCOL"
		ANSW=$PROTOCOL
      else
		PROTOCOL=0
		readln "Enter your choice ($PROTOCOL): "
      fi
      [ "$ANSW" ] && PROTOCOL="$ANSW"
      case "$PROTOCOL" in
	0|1|3)
           return ;;
	*)
	   PROTOCOL=""
           echo "This is not a valid menu option, redisplaying menu:";;
      esac
      NO_ERROR=no
    done
}
#
function hwconfig_menu () {
    while :; do
      echo
      echo "Check HW configuration/detection:"
      echo "1) Show all detected subchannels"
      echo "2) Show only subchannels that match a search expression"
#     echo "3) Change sort order of subchannel display: $SCH_ORDER"
#     echo "4) Change pattern of channels which are not shown: $DONTSHOW"
#     echo "5) Show the full output of /proc/chandev"
#     echo "6) Show detected devices of /proc/chandev"
#     echo "7) Show detected devices of /proc/chandev that match a search expression"
#     echo "8) Show devices enabled for detection in /proc/chandev"
      echo "9) Return to main menu"
      echo
      readln "Enter your choice (1-9): "
      case "$ANSW" in
	1)
	  echo "Showing all detected subchannels(dasd channels not shown):"
          show_subchannels | grep -v "$DONTSHOW"
	  press_return_to_continue
	  ;;
	2)
	  readln "Enter search expression: "
	  echo "Showing subchannels that match $ANSW(dasd channels not shown):"
          show_subchannels | grep -v "$DONTSHOW" | grep "$ANSW" >subchannels
	  if [ -s subchannels ]; then
		cat subchannels
	  else
		echo "No non-dasd subchannels matched $ANSW."
	  fi
	  press_return_to_continue
          ;;
#       3)
#         echo "Select new sort order"
#         ;;
#       4)
#         echo "Change pattern of channels which are not shown:"
#         ;;
        5)
	  echo "============================================================================="
	  echo "        Showing the contents of /proc/chandev(compressed output)"
	  echo "============================================================================="
	  sed -n 's/\(................................................................................\).*/\1/
			/^[=*]/d;
	       s/0x10  0x1731 0x01  0x1732 0x01/OSA Express Eth or Gigabit Eth/;
	       s/0x10  0x1731 0x05  0x1732 0x05/Hipersocket:(1731-05, 1732-05)/;
	       s/^0x//;s/^ //;s/0x/  /g;/./p' /proc/chandev
		  press_return_to_continue
	  ;;
        6)
	  echo "Showing the channels detected section of /proc/chandev:"
	  sed -n '1,/^channels detected/d;s/ *$//;/^[ =0]/p' /proc/chandev >channels
	  if [ -s channels ]; then
	  sed 's/0x10  0x1731 0x01  0x1732 0x01/OSA Express Eth or Gigabit Eth/;
               s/0x10  0x1731 0x05  0x1732 0x05/Hipersocket:(1731-05, 1732-05)/;
	       s/^0x//;s/^ //;s/0x/  /g;' channels
	  else
		echo "/proc/chandev does not show detected devices."
	  fi
	  press_return_to_continue
	  ;;
        7)
	  echo "Showing the channels detected section of /proc/chandev that match $ANSW:"
	  sed -n '1,/^channels detected/d;s/ *$//;/^[ =0]/p' /proc/chandev >channels
	  if [ -s channels ]; then
	        readln "Enter search expression: "
		grep "$ANSW" channels
	  else
		echo "/proc/chandev does not show detected devices."
	  fi
	  press_return_to_continue
	  ;;
        8)
	  echo "Showing the enabled channels of /proc/chandev, only the first 80 columns:"
          echo "The output is clipped at column 80 to fit on 80 column terminals"
	  echo "Channels enabled for detection:"
          sed '1,/^Channels enabled/d;/^$/,$d;s/\(................................................................................\).*/\1/' /proc/chandev
	  ;;
        9)
	  break;;
        *)
          echo "This is not a valid menu option, redisplaying menu:";;
      esac
    done
}
#
#
# Show all detected subchannels (in subchannel order) with their device IDs:
#
function show_subchannels () {
    echo -e "device\tonline\tcutype\tdevtype\tdetach_state"
    for i in /sys/bus/ccw/devices/*
    do
	echo -e "`basename $i`\t`cat $i/online`\t`cat $i/cutype`\t`cat $i/devtype`\t`cat $i/detach_state`"
    done
}
#
#
# Ask to press return to continue:
#
function press_return_to_continue () {
        echo -n "Press ENTER to continue: "
	read a
}
#
#
# Ask if the user want to see all detected subchannels:
#
function ask_show_subchannels () {
        yes_no "Do you want to see all detected (non-DASD) subchannels? (yes/no) "
        if [ "$ANSW" = "yes" ]; then
		show_subchannels | grep -v "3390/[0-9a-f][0-9a-f]"
		press_return_to_continue
	fi
}
#
#
# execcmd executes a command or displays it in debug mode
#
function execcmd () {
	CMD="$*"
	if [ "$DEBUG" = "yes" ]; then
		echo "--> "$CMD
	else
		eval $CMD
	fi
	EXIT_CODE=$?
}
#
#
# change_passwd asks for a new root password
#
function change_passwd() {
  echo " "
  echo "For security reasons you have to set an temporary installation"
  echo "system password for the user \"root\"."
  echo "You'll be asked for it only when you telnet into this installation"
  echo "system to limit the access to it and it will be cleared as soon"
  echo "as you shut down or reset the installation system"
  NO_ERROR=yes
  while :; do
    echo " "
    if [ "$AUTOINSTALL" = "yes" -a "$NO_ERROR" = "yes" ]
    then
	    echo "Please enter the temporary installation password: $INST_PASSWORD"
	    ANSW=$INST_PASSWORD
    else
	    readln "Please enter the temporary installation password: "
    fi
    [ ${#ANSW} -ge 3 ] && break;
    echo "Please enter at least 3 characters."
    NO_ERROR=no
  done
  echo "root:$ANSW" | execcmd "/usr/sbin/chpasswd" &&
    echo "Temporary installation password set."
}
#
#
function set_IP_DEV {
  [ "$NETSELECT" = "tr" ]      && IP_DEV=tr0
  [ "$NETSELECT" = "eth" ]     && IP_DEV=eth0
  [ "$NETSELECT" = "qeth" ]    && IP_DEV=eth0
  [ "$NETSELECT" = "hsi" ]     && IP_DEV=hsi0
  [ "$NETSELECT" = "ctc" ]     && IP_DEV=ctc0
  [ "$NETSELECT" = "escon" ]   && IP_DEV=escon0
  [ "$NETSELECT" = "iucv" ]    && IP_DEV=iucv0
  [ "$NETSELECT" = "qeth-tr" ] && IP_DEV=tr0
}
#
# select_network_device_type lets you choose the network connection
#
function select_network_device_type() {
    if [ "$NETSELECT" -a "$NETSELECT" != none ]; then
      echo "The selected network device type is $NETSELECT."
      yes_no "Do you want to change it (Yes/No) ?"
      [ "$ANSW" = no ] && return
    fi
    check_memory
    NO_ERROR="yes"
    while :; do
      CHAN=""
      echo
      echo "Please select the type of your network device:"
      echo " 0) no network"
      echo " 1) OSA Token Ring (lcs)"
      echo " 2) OSA Ethernet"
      echo " 3) OSA-Gigabit Ethernet or OSA-Express Fast Ethernet"
      echo " 4) Channel To Channel"
      echo " 5) Escon"
      echo " 6) IUCV"
      echo " 8) Hipersockets"
      echo " 9) OSA High speed Token Ring (qdio)"
      echo "10) Show subchannels and detected devices"
      if [ "$AUTOINSTALL" = "yes" -a "$NO_ERROR" = "yes" ]
      then
		case "$IP_INTERFACE" in
			tr) ANSW=1;;
			eth) ANSW=2;;
			qeth) ANSW=3;;
			ctc) ANSW=4;;
			escon) ANSW=5;;
			iucv) ANSW=6;;
			hsi) ANSW=8;;
			qeth-tr) ANSW=9;;
		esac
      else
		readln "Enter your choice (0-10): "
      fi
      echo
      case "$ANSW" in
	0)
#	  no network
	  NETSELECT="none"
          EXIT_SCRIPT=1
          no_network
	  break;;
        1)
	  NETSELECT="tr"
	  set_IP_DEV
	  if load_LCS; then
	      break
          fi;;
        2)
	  NETSELECT="eth"
	  set_IP_DEV
	  if load_LCS; then
	      break
          fi;;
        3)
 	  NETSELECT="qeth"
	  set_IP_DEV
          if load_QETH; then
              break
          fi;;
        4)
	  NETSELECT="ctc"
	  set_IP_DEV
          if load_CTC; then
            break
          fi;;
        5)
	  NETSELECT="escon"
	  set_IP_DEV
          if load_CTC; then
	    break
          fi;;
        6)
	  NETSELECT="iucv"
	  set_IP_DEV
          if load_IUCV; then
            break
          fi;;
        8)
          NETSELECT="hsi"
	  set_IP_DEV
	  if load_QETH; then
	    break
	  fi;;
	9)
	  NETSELECT="qeth-tr"
	  set_IP_DEV
	  if load_QETH; then
	      break
          fi;;
        10)
          hwconfig_menu
	  ;;
        *)
          echo "This is not a valid menu option, redisplaying menu:";;
      esac
      NO_ERROR=no
    done
}

#
# asks user whether to ignore the previous error
#
function continue_anyway()
{
        echo
        echo 'Do you want to ignore this error and continue anyway? (Yes/No)'
        yes_no
        if test "$ANSW" = "yes"
        then
                return 0
        else
                return 1
        fi
}

#
#
# activate_config establishes the network connection
# 
function activate_config() {
    export HOSTNAME=${IP_HOST%%.*}
    execcmd "/bin/hostname $HOSTNAME"
    dns_config
    ANSW="y"
    while [ "$ANSW" = "y" ] ; do
	IFCONFIG="ifconfig $IP_DEV $IP_ADDR"
	case "$NETSELECT" in
	    tr|eth|qeth|hsi|qeth-tr)
		IFCONFIG="$IFCONFIG netmask $IP_NETMASK broadcast $IP_BROADCAST" ;;
	    ctc|escon|iucv)
		IFCONFIG="$IFCONFIG pointopoint $IP_PEER" ;;
	esac
	if [ $IP_MTU != 0 ]; then
	    IFCONFIG="$IFCONFIG mtu $IP_MTU"
	fi
	echo "$IFCONFIG"
	execcmd "/sbin/$IFCONFIG"
	echo "/sbin/ifconfig $IP_DEV :"
	execcmd "/sbin/ifconfig $IP_DEV"
        sleep 1
	echo "Trying to ping my IP address:"
	execcmd "ping -w 10 -n -c 3 $IP_ADDR"
	if [ $EXIT_CODE -gt 0 ]; then
	    echo "Warning: Could not ping my IP address!"
	else
	    case "$NETSELECT" in
	    	tr|eth|qeth|hsi|qeth-tr)
                    NTRY=3
		    if [ "$IP_GATEWAY" ]; then
			echo "Trying to ping the IP address of the Gateway:"
			execcmd "ping -w 10 -n -c $NTRY $IP_GATEWAY" 
			if [ $EXIT_CODE -eq 0 ]; then
			    echo "Gateway seems to respond to our pings, continuing."
			    break
			else
			    echo "Warning: The gateway address $IP_GATEWAY did not ping."
			    continue_anyway && break
			fi
		    fi
		    ;;
		ctc|escon|iucv)
		    if [ "$IP_PEER" ]; then
                        if [ "$NETSELECT" != iucv ]; then
			    for i in 6 3 4 5 4 4 3 2
			    do
				if dmesg | tail | grep -q "$IP_DEV: connected with remote side"; then
					break
				fi
				echo "Waiting $i seconds for connection with remote side."
				sleep $i
			    done
			fi
			echo "Trying to ping the IP address of the peer:"
			execcmd "ping -w 10 -n -c 3 $IP_PEER"
			if [ $EXIT_CODE -eq 0 ]; then
			    echo "Peer seems to respond to our pings, continuing."
			    break
			else
			    echo "Warning: The peer address $IP_PEER did not ping."
			    case "$NETSELECT" in
				ctc|escon)
				    echo "Statistics from $IP_DEV:"
				    STATS_DIR=/sys/class/net/$IP_DEV/statistics
				    for file in $STATS_DIR/*; do
					if [ -r $file ]; then
					    read num < $file;
					    if [ $num -ne 0 ]; then
						echo $(basename $file): $num
					    fi
					fi
				    done
				;;
			    esac
			    continue_anyway && break
			fi
		    fi
		    ;;
		*)
		    echo "Something went wrong with $NETSELECT..."
	    esac
	fi
	readln "Do you want to retry the ifconfig (y/n)? "
    done
    if [ "$IP_GATEWAY" ] ; then
      execcmd "route add default gw $IP_GATEWAY"
    fi
    if [ "$IP_DNS" ]; then
	echo "Trying to ping the IP address of the DNS Server:"
	execcmd "ping -w 10 -c 3 $IP_DNS"
	if [ $EXIT_CODE -gt 0 ]; then
	    echo "Warning: The DNS address $IP_DNS did not ping."
	    echo "Diagnostics:"
	    echo "traceroute to the DNS IP with max ttl 10, waittime 1, one probe per hop:"
	    execcmd "traceroute -m 10 -n -w 1 -q 1 $IP_DNS"
	    echo "Flaky DNS will cause delays when logging in and during"
	    echo "Installation. To disable DNS enter: \"nodns\"."
	fi
    fi
    generate_installinf >$INSTALLINF
}
#
#
#
generate_installinf () {
#
# the following lines are not needed in install.inf
#Display: Color
#Keytable: de-lat1-nd
#Bootmode: CD
#Cdrom: /dev/hda
#Server:  10.10.0.10
#Serverdir: /work/CDs/full-i386
#Language: english
#
    echo "Bootmode: Net
Sourcemounted: 0
Netdevice: $IP_DEV
IP: $IP_ADDR
HostIP: $IP_ADDR
NetConfig: static"
    [ "$IP_MTU" -ne 0 ] && echo "MTU: $IP_MTU"
    case "$NETSELECT" in
	tr|eth|qeth|hsi|qeth-tr)
	    echo "Netmask: $IP_NETMASK"
	    echo "Broadcast: $IP_BROADCAST"
#	for qeth and hsi
	    [ "$NETSELECT" = "qeth" -o "$NETSELECT" = "hsi" -o "$NETSELECT" = qeth-tr ] && echo "WAIT_FOR_INTERFACES: 15"
	    ;;
	ctc|escon|iucv)
#
#	KRUECKE TODO
#	We need a networkmask to get linuxrc in batch-mode
#
	    echo "Netmask: $IP_NETMASK"
	    echo "Pointopoint: $IP_PEER"
#	Only for ctc and escon
	    [ ! "$NETSELECT" = "iucv" ] && echo "WAIT_FOR_INTERFACES: 40"
	    ;;
	*)
	    echo "Something went wrong with $NETSELECT..." >&2
    esac
    [ "$IP_GATEWAY" ] && echo "Gateway: $IP_GATEWAY"
    [ "$IP_SEARCH" ]  && echo "Domain: $IP_SEARCH"
    [ "$CHAN" ]       && echo "Hardware: $CHAN"
    if [ "$NETSELECT" = tr -o "$NETSELECT" = eth ]; then
      echo "Alias: $IP_DEV lcs"
#      echo "Options: lcs $PARM"
      echo "ConnectWait: 3"
    fi
    if [ "$NETSELECT" = "qeth" -o "$NETSELECT" = hsi -o "$NETSELECT" = qeth-tr ]; then
      echo "Alias: $IP_DEV qeth"
#      echo "Options: qeth $PARM"
      echo "ConnectWait: 15"
    fi
    if [ "$NETSELECT" = "ctc" -o "$NETSELECT" = "escon" ]; then
#      echo "Alias: $IP_DEV ctc"
#      echo "Options: ctc $PARM"
      echo "ConnectWait: 30"
    fi
    if [ "$NETSELECT" = "iucv" ]; then
#      echo "Alias: $IP_DEV netiucv"
      echo "$PARM" | sed "s/iucv=\(.*\)/Options: netiucv iucv=\1/g"
    fi
    [ "$IP_HOST" ]        && echo "Machinename: $IP_HOST"
    [ "$IP_DNS" ]         && echo "Nameserver: $IP_DNS"
    [ "$IP_MTU" -ne 0 ]   && echo "IP_MTU: $IP_MTU"
}
#
#
# at the end, run services
#
function run_services () {
  echo "Network Setup finished, running inetd..."
  echo pts/0 >> /etc/securetty
  echo pts/1 >> /etc/securetty
  echo pts/2 >> /etc/securetty
  execcmd "/usr/sbin/inetd &"
  execcmd "/sbin/portmap &"
  echo
  echo "You should be able to login via telnet now, for ssh wait a few seconds,"
  echo "temporary host keys (only for installation) are being generated now:"
  echo
  execcmd "/etc/init.d/sshd start"
  echo
  echo "Generation of temporary installation host keys finished."
  echo "After installation, new, different SSH keys will be generated."
  echo
# /usr/sbin/rpc.mountd -d call &
# /usr/sbin/rpc.nfsd -d auth &
}
#
#
# configure name resolving
#
function dns_config () {
  if [ "$DEBUG" = "yes" ]; then echo "-->(Installing /etc/resolv.conf)";return; fi
  cat > /etc/resolv.conf <<EOF
#
# /etc/resolv.conf
#
# Automatically generated by SuSE S/390 linuxrc (network setup)
#
# PLEASE DO NOT EDIT THIS FILE!
#
search $IP_SEARCH
nameserver $IP_DNS
EOF
}
#
#
# on failure, quit with this message
#
function no_network () {
  echo
  echo "*** OK, NETWORK ACCESS WILL _NOT_ BE AVAILABLE. ***"
  echo
}
function err () {
	echo "$@" >&2
}

#
function check_qeth_channels () {
    IFS="," read read write data rest
    if [ "$read" = auto ]; then
	echo auto
	return 0
    fi
    if [ -z "$read" -o -z "$write" -o -z "$data" ]; then
	err "qeth needs 3 four-digit hexadecimal numbers delimited by commas(,)."
	echo "$DEVS"
	return 1
    fi
    err=0
    for channel in read write data
    do
	eval devno=\$${channel}
	lcssid=${devno%.*}
	devid=${devno#?.?.}
        [ $channel != read ] && echo -n ,
	if [ "$devid" != "${devid//[^0-9a-fA-F.]/}" ]; then
           echo -n "[$devno]"
	   err "$channel channel address $devno contains non-hex characters, please check."
	   return 1
	fi
	devid=`printf %d 0x${devid}`
	if [ ${devid} -lt 0 -o ${devid} -gt 65535 ]; then
           printf '[0x%04x]' "$devid"
	   err "$channel channel address ${devid#0x} must be between 0 and 0xffff"
	   return 1
	fi
	devid=`printf %04x ${devid}`
        CHPIDs=`sed -n "s/^${devid} \([0-9a-f]*\) */\1/p" chandet.qeth`
	if [ -z "$CHPIDs" ]; then
	   err "$channel channel address ${devno} not found, please check."
	   return 1
	fi
	if [ "${last_CHIPDs}" -a "${CHPIDs}" != "${last_CHIPDs}" ]; then
	   err "$channel channel is CHPID ${CHPIDs//00/} while ${last_channel} channel is CHPID ${last_CHPIDs//00/}."
	   return 1
	fi
        eval ${channel}=${devid}
	if [ "$NETSELECT" = qeth -o "$NETSELECT" = qeth-tr ]; then
	  if [ $channel = read ] && [ $((0x$read & 1)) -eq 1 ]; then
		err "read channel address is odd, must be even!(incremented)"
		read="$((0x$read + 1))"
		devid=`printf %04x ${read}`
		err=1
	  fi
	  if [ $channel = write ] && [ $((0x$read + 1)) -ne $((0x$write)) ]; then
		err "write channel address must be the read channel address plus 1(corrected)"
		write="$((0x$read + 1))"
		devid=`printf %04x ${write}`
		err=1
	  fi
	fi
        last_channel=${channel}
        last_CHIPDs=${CHPIDs}
	echo -n "${lcssid}.${devid}"
    done
    #echo -n "${read},${write},${data}"
    [ "${rest}" ] && echo ",${rest}"
    return $err
}
#
#
#
function print_qeth_ranges () {
    IFS="," read read write data rest
    if [ $(($read - 1)) -eq $(($data)) ]; then
	echo "$data,$write"
    elif [ $(($write + 1)) -eq $(($data)) ]; then
	echo "$read,$data"
    else
	echo "$read,$write"
	echo "$data"
    fi
}
#
#
# ask for lcs parameters for OSA devices
#
function load_LCS () {
  if ! grep -q cu3088 /proc/modules ; then
    echo "Loading cu3088 module:"
    execcmd "/sbin/modprobe cu3088"
  fi
  
  ls /sys/bus/ccw/drivers/cu3088|while read device
  do
    echo "$device `cat /sys/bus/ccw/drivers/cu3088/$device/cutype`"
  done >lcs_detected
  #FIXME: filter out non-LCS devices
  
  if [ `grep '^0' lcs_detected | wc -l` -lt 2 ]; then
	echo "Could not find two(read/write) LCS Channels."
	ask_show_subchannels
	return 1
  fi
  echo "First 16 possible OSA / OSA-2 channel devices detected:"
  echo "chan_type is a bitfield of: CTC=1 ESCON=2 LCS=0x4"
  sort -k 2 lcs_detected | head -n 18
  echo 
  echo "We recommend to only use LCS autoprobing if Linux can see only two channel"
  echo "devices and you are sure that the relative adapter number 0 is not used"
  echo "by an other LPAR or Virtual Machine. For manual config, you have to enter"
  echo "the read channel device address (must be an even address). The write channel"
  echo "device number will be one greater. For autoprobing enter \"auto\"."
  AUTO_DEVNO="$DEVNO"
  [ -z "$DEVNO" -o "$DEVNO" = auto ] &&
	DEVNO=`sed -n 's/^\(0.0....[02468ace]\).*/\1/p' lcs_detected | head -n 1`
  ANSW="yes"
  NO_ERROR="yes"
  while [ "$ANSW" = "yes" ]; do
     while true; do
	if [ "$AUTOINSTALL" = "yes" -a "$NO_ERROR" = "yes" ]
	then
		echo "Enter the read channel device number, e.g. '0.0.fc20' (${DEVNO}): $AUTO_DEVNO"
		ANSW="$AUTO_DEVNO"
	else
		readln "Enter the read channel device number, e.g. '0.0.fc20' (${DEVNO}): "
	fi
	[ -z "$ANSW" ] && ANSW=$DEVNO
	if [ "$ANSW" = "auto" -o "$ANSW" = "AUTO" -o "$ANSW" = 0 ]; then
            DEVNO=auto
	    break
	fi
        ANSW="${ANSW}"
	if [ "$ANSW" != "${ANSW//[^.0-9a-fA-F]/}" ]; then
            echo "Invalid character detected, allowed hex numbers only consist of 0-9,a-f."
            NO_ERROR=no
	    continue
	fi
	ANSWh=${ANSW/[0-9].[0-9]./0x}
	if [ $(($ANSWh & 1)) -eq 1 ]; then
	    echo "Warning: You entered an odd read channel address, should be even!"
            NO_ERROR=no
	    continue
        fi
	if [ $(( $ANSWh )) -ge 0 -a $(( $ANSWh )) -le 65534 ]; then
            DEVNO="$ANSW"
	    DEVNOh="$ANSWh"
	    break
	fi
	echo
	echo "The read channel device number should be a hex number in the range of 0-FFFE."
        NO_ERROR=no
     done
     
     #shutdown_reset_conf_chandev
     if ! grep -q lcs /proc/modules; then
  	execcmd "/sbin/insmod lcs"
     fi
     
     if [ "$DEVNO" = "auto" -o "$DEVNO" = "AUTO" ]; then
        #FIXME: how does autoprobe work with 2.6?
	PARM=""
        CHAN=""
     else
        WRITE_DEVNO=`printf "0.0.%04x\n" $(($DEVNOh + 1))`
        echo
        echo "Please enter the relative port number on device address ${DEVNO}"
	if [ ! "$AUTOINSTALL" = "yes" -o "$NO_ERROR" = "no" ]
	then
		readln "Relative port, e.g. '0' ($PORTNO): "
		[ "$ANSW" ] && export PORTNO=$ANSW
	fi
        PARM="noauto=1 devno_portno_pairs=$DEVNO,$PORTNO"
	CHAN="lcs,$DEVNO,$WRITE_DEVNO,$PORTNO"
	echo "$DEVNO,$WRITE_DEVNO" >/sys/bus/ccwgroup/drivers/lcs
	#FIXME: I suppose I need to do something with $PORTNO as well...
     fi
     if grep lcs /proc/modules; then
       execcmd "/sbin/ifconfig $IP_DEV"
       if [ $EXIT_CODE -eq 0 ]; then
         ANSW="yes"
         echo "$IP_DEV is available, continuing with network setup."
         break
       else
         echo -e "\n$IP_DEV not available, check device addresses/cards and cables.\n"
       fi
     else
       echo -e "\nlcs module not loaded,  check device addresses/cards and cables.\n"
     fi
     yes_no "Do you want to retry the setup of the lcs module (Yes/No) ? "
     NO_ERROR=no
  done
  if [ "$ANSW" = "no" ]; then
     #shutdown_reset_conf_chandev
     false
  fi
}
#
#
# load the qeth driver
#
function load_QETH () {
  if [ ! -d /sys/bus/ccw/drivers/qeth ]; then
    echo "Loading qeth..."
    execcmd "/sbin/modprobe qeth_mod"
  fi

  if [ ! -d /sys/bus/ccw/drivers/qeth ]; then
      echo -e "\nqeth module not loaded, module problem.\n"
      yes_no "Do you want to retry the qeth-setup (Yes/No) ? "
      NO_ERROR=no
      return 1
  fi

  if [ "$NETSELECT" = hsi ]; then
    CUTYPE=05
    NETTYPE=Hipersocket
  else
    CUTYPE=01
    NETTYPE='OSA Express, Gigabit Ethernet or High Speed Token Ring'
  fi
  
  echo -n "Detecting available channels ... "
  rm -f chandet.qeth
  for i in /sys/bus/ccw/drivers/qeth/*
  do
    dn=`basename $i|sed "s,^[0-9].[0-9].,,"`
    chp=`cat $i/../chpids|sed "s, ,,g"`
    echo "$dn $chp" >>chandet.qeth
  done
  echo "done"

  NUMCHANS=`wc -l <chandet.qeth`
  echo $NUMCHANS "$NETTYPE Channels were detected."
  if [ $NUMCHANS -lt 3 ]; then
    echo "3 $NETTYPE Channels need to be detected to use $NETSELECT."
    ask_show_subchannels
    return 1
  fi
  if [ "$NETSELECT" = qeth -o "$NETSELECT" = qeth-tr ]; then
    grep '^...[02468ace] ' chandet.qeth >qeth_read_chans
    if [ ! -s qeth_read_chans ]; then
      echo "One even device address for OSA/QDIO Read Channel needs to exist!"
      ask_show_subchannels
      return 1
    fi
  fi
  if [ $NUMCHANS -gt 20 ]; then
    echo "Summary of all $NETTYPE channels detected:"
    echo "Device Addresses CHPID(s)"
    sed 's/^\(...\)./            \1?/;s/0* *$//g' chandet.qeth | sort -u +1
  fi
  echo "First $NETTYPE Channels that were detected:"
  echo "Device Addresses CHPID(s)"
  sed 's/^\(....\)/            \1/;s/0* *$//g' chandet.qeth|head -n 20

  if [ "$DEVNO" != auto -a "$DEVNO" != "${DEVNO//[^0-9a-fA-F]/}" ]; then
    echo "Device address $DEVNO contains non-hexadecimal characters, ignoring it."
    DEVNO=auto
  fi
  if [ "$DEVNO2" != auto -a "$DEVNO2" != "${DEVNO2//[^0-9a-fA-F]/}" ]; then
    echo "Device address $DEVNO2 contains non-hexadecimal characters, ignoring it."
    DEVNO2=auto
  fi
  if [ "$DEVNO3" != auto -a "$DEVNO3" != "${DEVNO3//[^0-9a-fA-F]/}" ]; then
    echo "Device address $DEVNO3 contains non-hexadecimal characters, ignoring it."
    DEVNO3=auto
  fi
  if [ "$DEVNO" != auto ]; then
    [[ "$DEVNO" == 0x* ]] || DEVNO=0x$DEVNO
    DEVNO=`printf %04x $DEVNO`
    grep -q "^${DEVNO} " chandet.qeth || {
      echo "Device address ${DEVNO#0x} not found, ignoring it."
      DEVNO=auto
    }
  fi
  if [ "$DEVNO2" != auto ]; then
    [[ "$DEVNO2" == 0x* ]] || DEVNO2=0x$DEVNO2
    DEVNO2=`printf %04x $DEVNO2`
    grep -q "^${DEVNO2} " chandet.qeth || {
      echo "Device address ${DEVNO2#0x} not found, ignoring it."
      DEVNO2=auto
    }
  fi
  if [ "$DEVNO3" != auto ]; then
    [[ "$DEVNO3" == 0x* ]] || DEVNO3=0x$DEVNO3
    DEVNO3=`printf %04x $DEVNO3`
    grep -q "^${DEVNO3} " chandet.qeth || {
      echo "Device address ${DEVNO3#0x} not found, ignoring it."
      DEVNO3=auto
    }
  fi
  if [ "$NETSELECT" = qeth -o "$NETSELECT" = qeth-tr ]; then
    echo
    echo "Format for OSA Express configuration: Read Channel,Write Channel,Data Channel"
    echo "The Read Channel must be an even device address,"
    echo "The Write Channel must be the Read Channel address plus 1,"
    echo "The Data Channel must be the Read Channel address plus 2."
    echo
    if [ $DEVNO != auto ] && [[ $DEVNO != ???[02468ace] ]]; then
      echo "Device address ${DEVNO} is not even, ignoring it."
      DEVNO=auto
    fi
    if [ $DEVNO2 != auto -a $DEVNO = auto ] && [[ $DEVNO2 == ???[13579bdf] ]]; then
      DEVNO=`printf %04x $(( 0x$DEVNO2 - 1 ))`
    fi
    while [ -s qeth_read_chans ]; do
      if [ "$DEVNO" != auto ]; then
        DEVNO1=$DEVNO
        DEVNO=auto
      else
        DEVNO1=`sed -n 's/^\(....\) .*/\1/p' qeth_read_chans | head -n 1`
      fi
      DEVNO2=`printf %04x $(( 0x$DEVNO1 + 1 ))`
      if grep -q "^${DEVNO2} " chandet.qeth; then
	CHPIDlist=`sed -n "s/^${DEVNO2} \([0-9a-f]*\) */\1/p" chandet.qeth`
	grep "${CHPIDlist}" chandet.qeth |
		grep -v -e "^${DEVNO1} " -e "^${DEVNO2} " > qeth_data_chans
        if [ "$DEVNO3" != auto ] && grep -q "^${DEVNO3} " qeth_data_chans; then
          DEVNO=$DEVNO1
          break
        fi
	DEVNO3=`sed -n 's/^\(....\) .*/\1/p' qeth_data_chans | head -n 1`
	if [ "$DEVNO3" ]; then
          DEVNO=$DEVNO1
	  break
	else
	  echo "No Data Channel address detected!"
	  ask_show_subchannels
	  return 1
	fi
      else
	mv qeth_read_chans qeth_read_chans.old
	grep -v "^$DEVNO1 " qeth_read_chans.old > qeth_read_chans
      fi
    done
    if [ "$DEVNO" = auto ]; then
      echo "No address for Read Channel with matching address for Write Channel detected!"
      ask_show_subchannels
      return 1
    fi
  else
    cp chandet.qeth chandet.hsi
    while [ -s chandet.hsi ]; do
      if [ "$DEVNO" != auto ]; then
        DEVNO1=$DEVNO
        DEVNO=auto
      else
        DEVNO1=`sed -n 's/^\(....\) .*/\1/p' chandet.hsi | head -n 1`
      fi
      CHPIDlist=`sed -n "s/^${DEVNO1} \([0-9a-f]*\) */\1/p" chandet.hsi`
      if [ "$DEVNO2" != auto ]; then
	grep -q -e "^${DEVNO2} ${CHPIDlist}" chandet.hsi || DEVNO2=auto
      fi
      if [ "$DEVNO2" = auto ]; then
        DEVNO2=`grep "${CHPIDlist}" chandet.hsi | grep -v "^${DEVNO1} "|head -n 1|sed -n 's/^\(....\) .*/\1/p'`
      fi
      if [ -z ${DEVNO2} ]; then
	mv chandet.hsi chandet.hsi.old
	grep -v "${CHPIDlist}" chandet.hsi.old > chandet.hsi
	continue
      fi
      if [ "$DEVNO3" != auto ]; then
	grep -q -e "^${DEVNO3} ${CHPIDlist}" chandet.hsi || DEVNO3=auto
      fi
      if [ "$DEVNO3" = auto ]; then
        DEVNO3=`grep "${CHPIDlist}" chandet.hsi |
		grep -v -e "^${DEVNO1} " -e "^${DEVNO2} "|head -n 1 |sed -n 's/^\(....\) .*/\1/p'`
      fi
      if [ -z ${DEVNO3} ]; then
	mv chandet.hsi chandet.hsi.old
	grep -v "${CHPIDlist}" chandet.hsi.old > chandet.hsi
	continue
      fi
      DEVNO=${DEVNO1}
      break
    done
    if [ "$DEVNO" = auto ]; then
      echo "Could not find 3 channels from the same CHPID!"
      ask_show_subchannels
      return 1
    fi
  fi
  echo "Possible configuration: read: 0x$DEVNO, write: 0x$DEVNO2, data: 0x$DEVNO3"
  DEVNOS=0.0.${DEVNO/auto/f801},0.0.${DEVNO2/auto/f802},0.0.${DEVNO3/auto/f803}
  DEVNOs="$DEVNOS"
  ANSW="yes"
  NO_ERROR="yes"
  while [ "$ANSW" = "yes" ]; do
     while true; do
	echo "Enter the device addresses for the qeth module, e.g. '$DEVNOs'"
	if [ "$AUTOINSTALL" = "yes" -a "$NO_ERROR" = "yes" ]
	then
		WRITE_DEVNO=`printf %04x $(( 0x$READ_DEVNO + 1 ))`
		ANSW="0.0.$READ_DEVNO,0.0.$WRITE_DEVNO,0.0.$DATA_DEVNO"
	else
		if [ -n "$READ_DEVNO" -a -n "$DATA_DEVNO" ]
		then
			WRITE_DEVNO=`printf %04x $(( 0x$READ_DEVNO + 1 ))`
			DEVNOS="0.0.$READ_DEVNO,0.0.$WRITE_DEVNO,0.0.$DATA_DEVNO"
		fi
		readln "($DEVNOS): "
		ANSW="`echo "$ANSW"|sed "s, ,,g"`"
		[ -z "$ANSW" ] && ANSW="$DEVNOS"
	fi
       DEVNOS=`echo "$ANSW"|check_qeth_channels` && break
       NO_ERROR=no
     done

     CCW_CHAN_IDS=""
     [ "$DEVNOS" != auto ] && CCW_CHAN_IDS="`echo $DEVNOS | sed -e 's@,@ @g'`"
     [ "$CCW_CHAN_IDS" ] && CCWGROUP_ID=${DEVNOS%%,*}
     [ "$DEVNOS" != auto ] && CHAN="qeth,$DEVNOS"
     if [ "$NETSELECT" = qeth -o "$NETSELECT" = qeth-tr -a "${DEVNOS/*,portname:*/}" ]; then
	NO_ERROR="yes"
        while true; do
	    if [ "$AUTOINSTALL" = "yes" ]
	    then
		ANSW="$PORTNAME"
	    else
		readln "Please enter the portname(case sensitive) to use($PORTNAME): "
	    fi
	    if [ ${#ANSW} -eq 0 -a ${#PORTNAME} -eq 0 ]; then
		echo "Warning: Only old MCLs allow empty portnames. Because not"
		echo "every operator may be aware of this config when updating"
		echo "the MCL, you may loose network as soon as it's updated."
		yes_no "Are you sure that you want to use an empty portname (Yes/No) ? "
		[ "$ANSW" != "yes" ] && continue
		ANSW=
	    fi
	    if [ ${#ANSW} -le 8 ]; then
		[ ${ANSW} ] && PORTNAME="${ANSW}"
		break
	    fi
            echo "The portname may not consist of more than 8 characters."
	    NO_ERROR=no
        done
     fi
     [ "$PORTNAME" ] && CHAN="$CHAN,$PORTNAME"

     rm -f /hotplug.msg
     echo "$DEVNOS" > /sys/bus/ccwgroup/drivers/qeth/group

     # Wait for CCWGROUP event
     for i in 2 1 2 3 4 5 6 7 8 9; do
	 sleep $i
	 if [ -s /hotplug.msg ]; then
	     if grep -q "ccwgroup" /hotplug.msg; then
		 dp=`grep ^DEVPATH= /hotplug.msg|sed s,DEVPATH=,,`
		 echo "Device $CCWGROUP_ID configured"
		 break
	     fi
	 fi
     done
     rm -f /hotplug.msg
     
     if [ "$dp" ]; then
	 if test "$PORTNAME"; then
	     echo "$PORTNAME" >/sys/$dp/portname
	 fi
	 
	 echo 1 >/sys/$dp/online
     else
	 echo "Device $CCWGROUP_ID could not be configured"
	 NO_ERROR="no"
	 return 1
     fi

     # Write hwcfg file
     hwcfg_file="/etc/sysconfig/hardware/hwcfg-qeth-bus-ccw-${CCWGROUP_ID}"

     cat > $hwcfg_file <<EOF
#!/bin/sh
#
# hwcfg-qeth-bus-ccw-${CCWGROUP_ID}
#
# Hardware configuration for a qeth device at ${CCWGROUP_ID}
# Automatically generated by netsetup
#

STARTMODE="auto"
MODULE="qeth_mod"
MODULE_OPTIONS=""
MODULE_UNLOAD="yes"

# Scripts to be called for the various events.
SCRIPTUP="hwup-ccw"
SCRIPTUP_ccw="hwup-ccw"
SCRIPTUP_ccwgroup="hwup-qeth"
SCRIPTDOWN="hwdown-ccw"

# CCW_CHAN_IDS sets the channel IDs for this device
# The first ID will be used as the group ID
CCW_CHAN_IDS="${CCW_CHAN_IDS}"

# CCW_CHAN_NUM set the number of channels for this device
# Always 3 for an qeth device
CCW_CHAN_NUM=3

EOF

     # Write the portname if set
     if [ "$PORTNAME" ]; then
	 cat >> $hwcfg_file <<EOF
# CCW_CHAN_MODE sets the port name for an OSA-Express device
CCW_CHAN_MODE="$PORTNAME"

EOF
     else
	 cat >> $hwcfg_file <<EOF
# CCW_CHAN_MODE sets the port name for an OSA-Express device
# CCW_CHAN_MODE=""

EOF
     fi

     for i in 2 1 2 3 4 5 6 7 8 9; do
	 sleep $i
         if [ -s /hotplug.msg ]; then
	     if grep -q "^INTERFACE=$IP_DEV" /hotplug.msg; then
		 echo "$IP_DEV detected!"
		 break
	     elif grep -q '^INTERFACE=' /hotplug.msg; then
		 dev=`grep ^INTERFACE= /hotplug.msg|sed s,INTERFACE=,,`
		 echo "$dev detected, expected $IP_DEV, aborting."
		 return 1
	     fi
         fi
     done
     execcmd "/sbin/ifconfig $IP_DEV"
     if [ $EXIT_CODE -eq 0 ]; then
         ANSW="yes"
         break
     else
         echo -e "\n$IP_DEV not available, check device addresses/cards.\n"
     fi
     yes_no "Do you want to retry the qeth-setup (Yes/No) ? "
     NO_ERROR=no
  done
  if [ "$ANSW" = "yes" -o "$ANSW" = "Yes" ]; then
     echo "$IP_DEV is available, continuing with network setup."
  else
     return 1
  fi
}
#
#
# load the ctc driver
#
function load_CTC () {
  if [ ! -d /sys/bus/ccwgroup/drivers/ctc ] ; then
      echo "Loading CTC module:"
      execcmd "/sbin/modprobe ctc"
  fi
  
  if [ ! -d /sys/bus/ccwgroup/drivers/ctc ] ; then
      echo -e "ctc module not loaded, module problem.\n"
      NO_ERROR=no
      return 1
  fi

  if [ "$NETSELECT" = escon ]; then
    NETTYPE=ESCON
    OTHERTYPE=CTC
  else
    NETTYPE=CTC
    OTHERTYPE=ESCON
  fi
  
  ls /sys/bus/ccw/drivers/cu3088|while read device
  do
    echo "$device `cat /sys/bus/ccw/drivers/cu3088/$device/cutype`"
  done >ctc_detected
  # FIXME: grep out OTHERTYPE
  if [ `cat ctc_detected | wc -l` -lt 2 ]; then
	echo "Couldn't find two $NETTYPE Channels (read and write)."
	ask_show_subchannels
	return 1
  fi
  echo "List of first 10 $NETTYPE Channels that were detected:"
  echo "Device   Channel type"
  head -n 10 ctc_detected
  ANSW="yes"
  NO_ERROR=yes
  while [ "$ANSW" = "yes" ]; do
	[ -z "$DEVNO" -o "$DEVNO" = auto ] &&
           DEVNO=`cut -d' ' -f 1 ctc_detected | head -n 1`
        LAST_DEVNO="$DEVNO"
	if [ "$AUTOINSTALL" = "yes" -a "$NO_ERROR" = "yes" ]
	then
		echo "Device address for read channel ($DEVNO): $READ_DEVNO"
		ANSW=$READ_DEVNO
	else
		[ -n "$READ_DEVNO" ] && DEVNO=$READ_DEVNO
		readln "Device address for read channel ($DEVNO): "
	fi
	[ "$ANSW" ] && export DEVNO=$ANSW
	grep "^$DEVNO " ctc_detected >ctc_DEVNO
	[ -s ctc_DEVNO ] || echo "Warning: $DEVNO is not a detected $NETTYPE channel"
	
	# Huh?
	#[ "$LAST_DEVNO" = "$DEVNO" ] || DEVNO2=`echo | sed -n "1,/$DEVNO /d;s/^\(....\).*/\1/p;q" - ctc_detected`
	
	[ -z "$DEVNO2" -o "$DEVNO2" = auto ] && DEVNO2=`cut -d' ' -f 1 ctc_detected | head -n 2|tail -n 1`
	if [ "$AUTOINSTALL" = "yes" -a "$NO_ERROR" = "yes" ]
	then
		echo "Device address for write channel ($DEVNO2): $WRITE_DEVNO"
		ANSW=$WRITE_DEVNO
	else
		[ -n "$WRITE_EVNO" ] && DEVNO2=$WRITE_DEVNO
		readln "Device address for write channel ($DEVNO2): "
	fi
	[ "$ANSW" ] && export DEVNO2=$ANSW
	grep "^$DEVNO2 " ctc_detected >ctc_DEVNO2
	[ -s ctc_DEVNO2 ] || echo "Warning: $DEVNO2 is not a detected $NETTYPE channel"
        ask_select_protocol
	
	echo "$DEVNO,$DEVNO2" >/sys/bus/ccwgroup/drivers/ctc/group
	echo "$PROTOCOL" >/sys/devices/cu3088/$DEVNO/protocol

	# Write hwcfg file

	rm -f /hotplug.msg
	echo 1 >/sys/devices/cu3088/$DEVNO/online
	
	for i in 1 2 3 4 5 6 7; do
	    sleep $i
            if [ -s /hotplug.msg ]; then
		if head -n 1 /hotplug.msg| grep -q '^net'; then
		    IP_DEV=`grep "^INTERFACE=" /hotplug.msg | sed "s,INTERFACE=,,"`
		    echo "$IP_DEV detected."
		    break
		fi
            fi
	done

	execcmd "/sbin/ifconfig $IP_DEV" >/dev/null
	if [ $EXIT_CODE -eq 0 ]; then
            ANSW="yes"
	    CHAN="ctc,$DEVNO,$DEVNO2,$PROTOCOL"
	    # Write hwcfg file
	    hwcfg_file="/etc/sysconfig/hardware/hwcfg-ctc-bus-ccw-${DEVNO}"
	    cat > $hwcfg_file <<EOF
#!/bin/sh
#
# hwcfg-ctc
#
# Hardware configuration for a ctc device at $DEVNO
# Automatically generated by $0
#

STARTMODE="auto"
MODULE="ctc"
MODULE_OPTIONS=""
MODULE_UNLOAD="yes"

# Scripts to be called for the various events.
SCRIPTUP="hwup-ccw"
SCRIPTUP_ccw="hwup-ccw"
SCRIPTUP_ccwgroup="hwup-ctc"
SCRIPTDOWN="hwdown-ccw"

# CCW_CHAN_IDS sets the channel IDs for this device
# The first ID will be used as the group ID
CCW_CHAN_IDS="$DEVNO $DEVNO2"

# CCW_CHAN_NUM set the number of channels for this device
# Always 2 for a CTC device
CCW_CHAN_NUM=2

EOF
	    if [ "$PROTOCOL" -ne "0" ]; then
		cat >> $hwcfg_file <<EOF
# CCW_CHAN_MODE sets the protocol for CTC / ESCON
# 0 for compability mode (default)
# 1 for extended mode
# 2 for CTC-based tty
# 3 for compability mode with OS/390 and z/OS
CCW_CHAN_MODE="$PROTOCOL"

EOF
	    else
		cat >> $hwcfg_file <<EOF
# CCW_CHAN_MODE sets the protocol for CTC / ESCON
# 0 for compability mode (default)
# 1 for extended mode
# 2 for CTC-based tty
# 3 for compability mode with OS/390 and z/OS
# CCW_CHAN_MODE="$PROTOCOL"

EOF
	    fi
            break
	else
            echo -e "\n$IP_DEV not available, check device addresses.\n"
	fi
        yes_no "Do you want to retry to configure $IP_DEV (Yes/No) ? "
	NO_ERROR=no
  done
  if [ "$ANSW" = "yes" ]; then
     echo "$IP_DEV is available, continuing with network setup."
  else
     false
  fi
}
#
#
# load the iucv driver
#
function load_IUCV () {
  ANSW="yes"
  NO_ERROR="yes"
  while [ "$ANSW" = "yes" ]; do
    echo "Please enter the name(userid) of the target VM guest here."
    echo "In VIF this is normally \$TCPIP, in VM normally TCPIP."
    echo ""
    if [ "$AUTOINSTALL" = "yes" -a "$NO_ERROR" = "yes" ]
    then
	echo "The name of the peer guest, e.g. 'TCPIP' ($PEER): $AUTO_PEER"
	ANSW=$AUTO_PEER
    else
	[ -n "$AUTO_PEER" ] && PEER=$AUTO_PEER
	readln "The name of the peer guest, e.g. 'TCPIP' ($PEER): "
    fi
    [ "$ANSW" ] && export PEER=$ANSW

    IUCVDIR="/sys/bus/iucv/drivers/netiucv"
    if [ -d "$IUCVDIR" ]; then
      echo "Unloading netiucv, iucv modules..."
      execcmd "/sbin/rmmod netiucv"
      execcmd "/sbin/rmmod iucv"
    fi
    echo "Trying to start the netiucv module now..."
    echo "modprobe netiucv:"
    execcmd "/sbin/modprobe netiucv"
    if [ -d "$IUCVDIR" ]; then
      echo "netiucv module is loaded, activating it."
      echo "$PEER" > $IUCVDIR/connection
      CHAN="iucv,$PEER"
      echo "checking interface $IP_DEV."
      execcmd "/sbin/ifconfig $IP_DEV"
      if [ $EXIT_CODE -eq 0 ]; then
        ANSW="yes"
        break
      else
        echo "Error: $IP_DEV is not available, likely a problem connecting to the target."
      fi
    else
      echo "Error: The netiucv module could NOT be loaded."
    fi
    yes_no "Do you want to retry the setup of IUCV (Yes/No) ? "
    NO_ERROR=no
  done
  if [ "$ANSW" = "yes" ]; then
     echo "$IP_DEV seems to exist, continuing with network setup."
     hwcfg_file="/etc/sysconfig/hardware/hwcfg-iucv-id-${PEER}"
     cat > $hwcfg_file <<EOF
#!/bin/bash
#
# hwcfg-iucv
#
# Hardware configuration for an iucv device with link partner '$PEER'
# Automatically generated by $0
#

STARTMODE="auto"
MODULE="netiucv"
MODULE_OPTIONS=""
MODULE_UNLOAD="yes"

# Scripts to be called for the various events.
SCRIPTUP="hwup-iucv"

EOF
  else
     false
  fi
}
#
#
# checks an IP to have numbers only between 0 and 255:
#
# example:
# if echo $IP_ADDR | check_ip; then ...
#
function check_ip()
{
        IFS=". " read ip1 ip2 ip3 ip4 rest
        for i in ip1 ip2 ip3 ip4
        do
                eval x=\$$i
                if [ $x -lt 0 -o $x -gt 255 ]; then
                        echo "$x: Value must be between 0 and 255"
                        return 1
                fi
        done
        return 0
}
#
#
# calculates the broadcast address; parameters are IP_ADDR and IP_NETMASK
#
function calc_broadcast_enh()
#
# STDIN: IP, NETMASK
# STDOUT: BROADCAST
{
        IFS=". " read ip1 ip2 ip3 ip4  nm1 nm2 nm3 nm4 rest
        echo $(( ($ip1 & $nm1 | ~$nm1) & 255)).$(( ($ip2 & $nm2 | ~$nm2) & 255)).$(( ($ip3 & $nm3 | ~$nm3) & 255)).$((($ip4 & $nm4 | ~$nm4) & 255))
}

# suggest a gateway address
function calc_gateway()
{
	IFS=". " read ip1 ip2 ip3 ip4  nm1 nm2 nm3 nm4 rest
	echo $(($ip1 & $nm1)).$(($ip2 & $nm2)).$(($ip3 & $nm3)).$((($ip4 & $nm4) + 1))
}

#
#
# MAIN
#
#
#
# If we are not started by init (we are linuxrc), we have to make sure
# that we have an suitable PATH for us and the user:
#
PATH=/sbin:/bin:/usr/sbin:/usr/bin
#
#
# Ensure that we have /proc, /sys mounted:
#
[ ! -f /proc/version ] && mount -t proc virtual-proc-filesystem /proc
[ ! -d /sys/devices ] && mount -t sysfs none /sys
[ ! -d /etc/sysconfig/hardware ] && mkdir /etc/sysconfig/hardware
#
#
# We want to save the kernel message ring buffer to a file:
#
[ ! -e /boot.msg ] && dmesg > /boot.msg
#
# set debug to yes/no
#set -vx
: ${DEBUG:=no}
#
if [ "$DEBUG" = "no" ]
then
	INSTALLINF="/etc/netsetup.inf"
else
	INSTALLINF="./netsetup.inf"
fi
#
if [ "$DEBUG" = "no" ]; then
	if [ -e /linuxrc.init ]; then
		. /linuxrc.init
		rm /linuxrc.init
#
#		We use the initenv from the kernel parmfile only in the first run
#
		for i in 1 2 3 4 5 6 7 8 9
		do
			eval LINUXRC_READLINE="\$LINUXRC_READ$i"
			if [ "$LINUXRC_READLINE" ]; then
				LINUXRC_READ="$LINUXRC_READ $LINUXRC_READLINE"
			fi
		done
		if [ "$LINUXRC_READ" ]; then
			LINUXRC_READ="`echo $LINUXRC_READ|sed 's/\"//g'`"
			echo "Found this input script for linuxrc: $LINUXRC_READ"
		fi
	fi
else
	if [ -e ./linuxrc.init.debug ]; then
		. ./linuxrc.init.debug
		rm ./linuxrc.init.debug
	fi
#	export -p
fi
#
echo "\
=                                                                   =
==-    Welcome to `grep ^Product /linuxrc.config|tail -n 1|sed s,^Product:[[:space:]]*,,g`      -==
=                                                                   ="
[ "$DEBUG" = "yes" ] && echo -e "\n- Running in DEBUG mode. -\n"
EXIT_SCRIPT=0
CONFIG_IS_OK=0
while [ $CONFIG_IS_OK = 0 ]; do
  select_network_device_type
  [ $CONFIG_IS_OK = 1 -o $EXIT_SCRIPT = 1 ] && break
  echo
  if [ "$AUTOINSTALL" = "yes" ]
  then
	  echo "Please enter your full host name, e.g. 'linux.example.com' ($IP_HOST): $IP_HOST"
	  echo "Please enter your IP address, e.g. '192.168.0.1' ($IP_ADDR): $IP_ADDR"
	  export IP_ADDR IP_HOST
  else
	  readln "Please enter your full host name, e.g. 'linux.example.com' ($IP_HOST): "
	  [ "$ANSW" ] && export IP_HOST=$ANSW
	  readln "Please enter your IP address, e.g. '192.168.0.1' ($IP_ADDR): "
	  [ "$ANSW" ] && export IP_ADDR=$ANSW
  fi
  case "$NETSELECT" in
    tr|eth|qeth|hsi|qeth-tr)
	    if [ "$AUTOINSTALL" = "yes" ]
	    then
		    echo "Please enter the net mask, e.g. '255.255.255.0' ($IP_NETMASK): $IP_NETMASK"
		    IP_BROADCAST=$(echo $IP_ADDR $IP_NETMASK | calc_broadcast_enh)
		    echo "Please enter the broadcast address if different from ($IP_BROADCAST): $IP_BROADCAST"
		    echo "Please enter the gateway's IP address, e.g. '192.168.0.254' ($IP_GATEWAY): $IP_GATEWAY"
		    export IP_NETMASK IP_BROADCAST IP_GATEWAY
	    else
		    readln "Please enter the net mask, e.g. '255.255.255.0' ($IP_NETMASK): "
		    [ "$ANSW" ] && export IP_NETMASK=$ANSW
		    IP_BROADCAST=$(echo $IP_ADDR $IP_NETMASK | calc_broadcast_enh)
		    readln "Please enter the broadcast address if different from ($IP_BROADCAST): "
		    [ "$ANSW" ] && export IP_BROADCAST=$ANSW
		    IP_GATEWAY=$(echo $IP_ADDR $IP_NETMASK | calc_gateway)
		    readln "Please enter the gateway's IP address, e.g. '192.168.0.254' ($IP_GATEWAY): "
		    [ "$ANSW" ] && export IP_GATEWAY=$ANSW
	    fi
	    ;;
#    peer-to-peer networks
    ctc|escon|iucv)
	    if [ "$AUTOINSTALL" = "yes" ]
	    then
		    echo "Please enter the IP address of your peer, e.g. '192.168.0.254' ($IP_PEER): $IP_PEER"
		    export IP_PEER
	    else
		    readln "Please enter the IP address of your peer, e.g. '192.168.0.254' ($IP_PEER): "
		    [ "$ANSW" ] && export IP_PEER=$ANSW
	    fi
	    export IP_GATEWAY=$IP_PEER
	    export IP_NETMASK=255.255.255.255
	    ;;
    *)
	    echo "Something went wrong with $NETSELECT..."
  esac
  if [ "$AUTOINSTALL" = "yes" ]
  then
	  echo "Please enter the IP address of the DNS server or 'none' for no DNS ($IP_DNS): $IP_DNS"
	  export IP_DNS
  else
	  readln "Please enter the IP address of the DNS server or 'none' for no DNS ($IP_DNS): "
	  [ "$ANSW" ] && export IP_DNS=$ANSW
  fi
  [ "$IP_DNS" = "none" -o "$IP_DNS" = "NONE" ] && export IP_DNS=""
  if [ "$IP_DNS" ]; then
    [ -z "$IP_SEARCH" ] && IP_SEARCH=${IP_HOST#*.}
    if [ "$AUTOINSTALL" = "yes" ]
    then
	    echo "Please enter the DNS search domain, e.g. 'example.com' ($IP_SEARCH): $IP_SEARCH"
	    export IP_SEARCH
    else
	    readln "Please enter the DNS search domain, e.g. 'example.com' ($IP_SEARCH): "
	    [ "$ANSW" ] && export IP_SEARCH=$ANSW
    fi
  else
    IP_SEARCH=none
  fi
  [ "$IP_SEARCH" = "none" -o "$IP_SEARCH" = "NONE" ] && export IP_SEARCH=""
  while true; do
    if [ "$IP_MTU" = "default" ]; then
      case "$NETSELECT" in
	tr|eth)
	    export IP_MTU=1492
	    ;;
	ctc|qeth|qeth-tr)
	    export IP_MTU=1500
	    ;;
	iucv)
	    export IP_MTU=9216
	    ;;
        escon)
	    export IP_MTU=32760
	    ;;
        hsi)
            # Do not set mtu, hipersocket should use IOCDS/Channel default
	    export IP_MTU="max. Socket MTU"
	    ;;
	*)
	    echo "Something went wrong with $NETSELECT..."
      esac
    fi
    if [ "$AUTOINSTALL" = "yes" ]
    then
	    echo "Please enter the MTU (Maximum Transfer Unit),"
	    echo "leave blank for default: ($IP_MTU): $IP_MTU"
	    ANSW=$IP_MTU
    else
	    echo "Please enter the MTU (Maximum Transfer Unit),"
	    readln "leave blank for default: ($IP_MTU): "
    fi
    echo
    [ "$ANSW" ] && export IP_MTU=$ANSW
    [ $(( ${IP_MTU//[A-z]*/} + 0 )) -eq 0 ] && IP_MTU=0
    case "$NETSELECT" in
      ctc|escon|iucv)
        [ $IP_MTU -ge 576 -a $IP_MTU -le 32768 -o $IP_MTU = 0 ] && break
	echo "For the CTC/IUCV driver, the MTU must be in the range 576-32768."
        ;;
      tr|eth)
    	[ $IP_MTU -ge  68 -a $IP_MTU -le 1500 -o $IP_MTU = 0 ] && break
	echo "For the LCS driver, the MTU must be in the range 68-1500."
        ;;
      qeth|qeth-tr)
    	[ $IP_MTU -ge 576 -a $IP_MTU -le 1500 -o $IP_MTU = 0 ] && break
	echo "The installation MTU range for qeth is 576-1500, set other values later."
	;;
      hsi)
	break
	;;
    esac
    IP_MTU=default
  done
  echo "Configuration for $IP_DEV will be:"
  [ $IP_HOST ] && echo "Full host name   : $IP_HOST"
  echo "IP address       : $IP_ADDR"
  case "$NETSELECT" in
    tr|eth|qeth|hsi|qeth-tr)
	    echo "Net mask         : $IP_NETMASK"
	    [ "$IP_BROADCAST" ] && echo "Broadcast address: $IP_BROADCAST"
	    [ "$IP_GATEWAY" ] && echo "Gateway address  : $IP_GATEWAY"
	    ;;
    ctc|escon|iucv)
	    echo "Peer IP address  : $IP_PEER"
	    ;;
    *)
	    echo "Something went wrong with $NETSELECT..."
  esac
  [ "$IP_DNS" ] && echo "DNS IP address   : $IP_DNS"
  [ "$IP_SEARCH" ] && echo "DNS search domain: $IP_SEARCH"
  if test $IP_MTU ; then
    if [ $IP_MTU != 0 ]; then
      echo "MTU size         : $IP_MTU"
    else
      echo "MTU size         : default interface MTU"
    fi
  fi
  if [ "$AUTOINSTALL" = "yes" ]
  then
	  echo "Is this correct (Yes/No) ? yes"
	  ANSW="yes"
  else
	  yes_no "Is this correct (Yes/No) ? "
  fi
  if [ "$ANSW" = "yes" ]; then
    change_passwd
    activate_config
    CONFIG_IS_OK=1
  fi
done
[ $EXIT_SCRIPT = 0 ] && run_services
#
[ "$LINUXRC_RECORD" ] && echo "LINUXRC_READ=\"$LINUXRC_READ\""
check_memory
check_memory >> /etc/motd

