#! /usr/bin/perl

#
# !!! sorry, doc is outdated !!!
#

# Create a boot disk and put everything on it.
#
# Source files and the file list are taken from data/boot; the image is
# stored in images/boot.
#
# The maximum possible initrd size is returned in tmp/boot.max_initrd_size.
#
# Usage:        mk_boot

=head1 mk_boot

C<mk_boot> creates a boot disk.

It packs the files from C<data/boot/boot.file_list> into a 1.44M FAT image
and stores the image file as C<images/boot>.

In addition to making a boot image, C<mk_boot> writes the maximum allowed
size for C<initrd> to C<tmp/boot.max_initrd_size>. This is intended to be
potentially useful for the C<mk_initrd> script (but currently this info
isn't used).

C<mk_boot> creates a FAT file system with only one FAT and with 15 root directory
entries. This saves 11 kbytes on a 1.44M floppy.

Note: if by any chance your C<initrd> is just too big by a few
I<bytes>, you can try varying the cluster size. It I<may> help.

=cut


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# the usual fuss...

BEGIN { unshift @INC, ( $0 =~ /(.*?)((?<![^\/])bin\/)?[^\/]+$/ )[0] . "lib" }
use ReadConfig;
use AddFiles;
use MakeFATImage;

sub opt_initrd;

die "usage: $Script\n" if @ARGV;


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# some config data

$srcdir = "${DataPath}boot";
$tmpdir = "${BasePath}tmp";
$tmpbootdir = "${BasePath}tmp/boot";
$image = "${ImagePath}boot";
$initrddir = "$tmpdir/initrd";
$initrddirx = "$tmpdir/.initrd";
$initdisk = "${ImagePath}initrd";
$initrdondisk = "initrd";

$image .= ".$ENV{'boot'}" if defined $ENV{'boot'};
if($ENV{'noinitrd'}) {
  $noinitrd = $ENV{'noinitrd'};
  $tinyinitdisk = "${ImagePath}$noinitrd";
}

$initdisk = "${ImagePath}$ENV{'initrd_name'}" if $ENV{'initrd_name'};
$initrdondisk = $ENV{'initrd_name'} if $ENV{'initrd_name'};

# mbr boot program (ia32 only)
$mboot_file = "${BasePath}src/mboot/mboot";

$arch = $ConfigData{suse_arch};
$ia32_like = $arch eq 'i386' || $arch eq 'x86_64';

$fstype = $ia32_like ? 'msdos' : 'vfat';

# clean up
if(-d($tmpbootdir)) {
  SUSystem "rm -rf $tmpbootdir" and die "$Script: failed to remove old $tmpbootdir";
}

mkdir $tmpdir || die "$Script: failed to create $tmpdir";


if($ia32_like) {
  if($ENV{'syslinux'}) {
    $syslx = $ENV{'syslinux'};
  } else {
    $syslx = "${BasePath}tmp/base/usr/sbin/syslinux"
  }
  die "$Script: where is syslinux?" unless -x $syslx;

  if($ENV{'isolinux'}) {
    $isolx = $ENV{'isolinux'};
  } else {
    $isolx = "${BasePath}tmp/base/usr/share/syslinux/isolinux.bin"
  }
  die "$Script: where is isolinux?" unless -f $isolx;
}

# print STDERR "syslinux = $syslx, isolinux = $isolx\n";

#$kernel = "$BasePath$ConfigData{kernel}";
#die "$Script: which kernel do we use?" unless $ConfigData{kernel} && -f $kernel;

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# now we really start...

# clean up
if(-d $initrddirx) {
  die "$Script: the initrd must be rebuilt";
}

if(-e $image) {
  SUSystem "rm -rf $image" and die "$Script: failed to remove old $image";
}

($i1, $i2) = split /\./, $ConfigData{suse_release};

if($ConfigData{product_name} eq "UnitedLinux") {
  $label = "UNITEDLINUX";
}
else {
  $label = "SUSE${i1}${i2}_BOOT";
}

# create an empty image
if($ENV{'boot'} eq 'small') {
  ($blocks, $block_size) = MakeFATImage($image, $label, 1)
}
elsif($ENV{'boot'} eq 'medium') {
  ($blocks, $block_size) = MakeFATImage($image, $label, 2, 36)
}
elsif($ENV{'boot'} eq 'hd') {
  # about 20MB image; see lib/MakeFATImage.pm for the meaning of the args
  ($blocks, $block_size) = MakeFATImage($image, $label, 2, 63, 4, 160, "$image.mbr", $mboot_file)
}
elsif($ENV{'boot'} eq 'large' || ($arch eq 'ia64' && !$ENV{'boot'})) {
  # about 20MB image; see lib/MakeFATImage.pm for the meaning of the args
  ($blocks, $block_size) = MakeFATImage($image, $label, 2, 63, 16, 40)
}
elsif($ENV{'boot'} eq 'isolinux') {
  SUSystem "mkdir $image";

  # copy everything *except* the initdisk
  AddFiles $tmpbootdir, "${srcdir}/boot.file_list", $srcdir or
    die "$Script: failed to setup boot image";

  SUSystem "cp -a $tmpbootdir/* $image" and
    die "$Script: failed to setup boot image";

  SUSystem "mv $image/syslinux.cfg $image/isolinux.cfg" and
    die "$Script: syslinux.cfg missing";

  SUSystem "sh -c 'pisolinux /boot/loader <$isolx >$image/isolinux.bin'" and
    die "$Script: isolinux.bin missing";

  # copy the initdisk
  SUSystem "cp $initdisk $image" and
    die "$Script: could not add $initdisk to the image";

  print "contents of $image:\n";
  system "ls -l $image";

  exit 0;
}
else {
  ($blocks, $block_size) = MakeFATImage($image, $label, 2, 36)
}

die "$Script: failed to create FAT disk image \"$image\"\n" unless defined $blocks;

printf "$Script: image \"%s\", %u blocks a %u bytes (%u total)\n", $image, $blocks, $block_size, $blocks * $block_size;

# make it bootable and add syslinux
if($ia32_like) {
  $xx = "-s" if $ENV{boot} eq 'small' && !$ENV{fastboot};
  SUSystem "$syslx $xx $image" and
    die "$Script: syslinux failed";
}

# umount it first, just in case
SUSystem "umount /mnt 2>/dev/null";

# add the other files
SUSystem "mount -oloop -t $fstype $image /mnt" and
  die "$Script: mount failed";

# copy everything *except* the initdisk
AddFiles $tmpbootdir, "${srcdir}/boot.file_list", $srcdir or
  die "$Script: failed to setup boot image";

if ($arch eq 'x86_64'){
 SUSystem "rm $tmpbootdir/bootlogo";
}

SUSystem "cp -a $tmpbootdir/* /mnt" and
  die "$Script: failed to setup boot image";

if($ia32_like) {
  SUSystem "umount /mnt" and
    die "$Script: umount failed";

  Print2File $MToolsCfg, "drive r: file=\"$image\"\n" or die "$Script: oops!";
  @f = `mdir r:`;
  unlink $MToolsCfg;

  for (@f) {
    if(/^\s*([ 0-9]+?)\s+bytes\s+free\s*$/) {
      $free = $1;
      $free =~ s/\s+//g;
      last;
    }
  }

  die "$Script: oops, no space on boot disk???" unless defined $free;

  print "$Script: prepared boot disk \"$image\"; $free bytes for initrd\n";

  # Print2File "$tmpdir/initrd.max_size", "$free\n" or die "$Script: oops!";

  if($noinitrd) {
    $j = -s $tinyinitdisk;
    $tinyinitdisk = undef, $j = 0 unless $j > 0 && $j - $free < 0;
  }
  else {
    $j = -s $initdisk;
    die "$Script: $initdisk missing" unless $j > 0;
  }
  $k = $j - $free;
  if($k >= 0) {
    print "$Script: $initdisk $k bytes too big\n";
    opt_initrd $free;
    $j = -s $initdisk;
    $k = $j - $free
  }
  else {
    if($ENV{'boot'} eq 'hd') {
      my ($t);

      # make it fit

      $t = int(($blocks * $block_size + $k + 100000) / (63 * 4 * 512) + 1);

      ($blocks, $block_size) = MakeFATImage($image, $label, 2, 63, 4, $t, "$image.mbr", $mboot_file);

      die "$Script: failed to create FAT disk image \"$image\"\n" unless defined $blocks;

      printf "$Script: image \"%s\", %u blocks a %u bytes (%u total)\n", $image, $blocks, $block_size, $blocks * $block_size;

      # make it bootable and add syslinux
      if($ia32_like) {
        $xx = "-s" if $ENV{'boot'} eq 'small';
        SUSystem "$syslx $xx $image" and
          die "$Script: syslinux failed";
      }

      # umount it first, just in case
      SUSystem "umount /mnt 2>/dev/null";

      # add the other files
      SUSystem "mount -oloop -t $fstype $image /mnt" and
        die "$Script: mount failed";

      # copy everything *except* the initdisk
      AddFiles $tmpbootdir, "${srcdir}/boot.file_list", $srcdir or
        die "$Script: failed to setup boot image";

      SUSystem "cp -a $tmpbootdir/* /mnt" and
        die "$Script: failed to setup boot image";

      SUSystem "umount /mnt" and
        die "$Script: umount failed";

      Print2File $MToolsCfg, "drive r: file=\"$image\"\n" or die "$Script: oops!";
      @f = `mdir r:`;
      unlink $MToolsCfg;

      for (@f) {
        if(/^\s*([ 0-9]+?)\s+bytes\s+free\s*$/) {
          $free = $1;
          $free =~ s/\s+//g;
          last;
        }
      }

      die "$Script: oops, no space on boot disk???" unless defined $free;

      print "$Script: prepared boot disk \"$image\"; $free bytes for initrd\n";

      $j = -s $initdisk;
      die "$Script: $initdisk missing" unless $j > 0;

    }
  }
  die "$Script: $initdisk $k bytes too big! ($j)\n" unless $j < $free;
  $xfree = $free - $j;

  # add the initdisk
  SUSystem "mount -oloop -t $fstype $image /mnt" and
    die "$Script: mount failed";
}

# copy the initdisk
if($noinitrd) {
  if($tinyinitdisk) {
    SUSystem "cp $tinyinitdisk /mnt/small" and
      die "$Script: could not add $tinyinitdisk to the image";
  }
}
else {
  if ($arch eq 'ia64') {
    $subdir = 'efi/boot/';
  }
  else {
    $subdir = '';
  }
  SUSystem "cp $initdisk /mnt/$subdir$initrdondisk" and
    die "$Script: could not add $initdisk to the image";
}

$i3 = $i2*10;
SUSystem "touch -d $i1:$i3 /mnt/*";

print "contents of $image:\n";
system "ls -lR /mnt";

SUSystem "umount /mnt" and
  die "$Script: umount failed";

if($ENV{'boot'} eq 'hd') {
  my $lo;

  $lo = -s "$image.mbr";
  system "cat $image >>$image.mbr";
  system "mv $image.mbr $image";

   print "$Script: finished boot disk \"$image\" (offset $lo)";
}
else {
  print "$Script: finished boot disk \"$image\"";
}

print defined($xfree) ? "; $xfree bytes free\n" : "\n";

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# remove files from initrd until it fits to the disk
#
sub opt_initrd
{
  my ($isize, $maxsize, @mlist, %mlist, @mods, %mods, $i, $j, $m);
  my (@xl, $rb, $gzsize, $tsize, $lastfree);
  local ($_);

  $maxsize = shift;
  $isize = -s $initdisk;
  die "$Script: failed to create $initrddirx ($!)" unless mkdir $initrddirx, 0777;
  $ENV{'keepinitrd'} = 1;
  open M, "$tmpdir/initrd.opt_mods"; @mlist = <M>; close M;
  chop @mlist;
  $j = 0;
  for (@mlist) {
    $i = $_;
    $i =~ s/.*\///;
    push @mods, $i;
    $mlist{$_} = $j;
    $mods{$i} = $j;
    $j++;
  }

  # first, remove all optional mods
  for (@mlist) {
    SUSystem "mv $initrddir/$_ $initrddirx/$m";
  }

  # see if that works
  system "bin/mk_initrd";
  $isize = -s $initdisk;
  die "$Script: $initdisk missing" unless $isize > 0;
  if($isize >= $maxsize) {
    $i = $isize - $maxsize;
    print "$Script: initrd $i bytes too big: make more modules optional\n";
  }
  else {
    $i = $maxsize - $isize;
    print "$Script: $i bytes left for optional modules\n";
  }

  # now re-add them one by one
  if($isize < $maxsize) {
    $lastfree = $maxsize - $isize;
    # see if we can add some mods
    for (@mlist) {
      $m = $mods[$mlist{$_}];
      die "$Script: oops" if $m eq "";
      $j = -s "$initrddirx/$m";
      if($j) {
        $gzsize = `gzip -c -9 $initrddirx/$m | wc -c` + 0;
      }
      else {
        $gzsize = 0;
      }
      $tsize = $gzsize > 1024 ? $gzsize / 2 : 0;
      if($tsize <= $lastfree) {
        print "$Script: trying to add $_ ($j/$gzsize bytes)\n";
        SUSystem "mv $initrddirx/$m $initrddir/$_";
        system "bin/mk_initrd";
        $isize = -s $initdisk;
        die "$Script: $initdisk missing" unless $isize > 0;
        $rb = 0;
        $j = $maxsize - $isize;
        if($isize >= $maxsize) {
          print "$Script: well, that was too much ($j bytes left)\n";
          SUSystem "mv $initrddir/$_ $initrddirx/$m";
          $rb = 1;
        }
        else {
          $lastfree = $j;
          print "$Script: yup, that worked ($j bytes left)\n";
        }
      }
      else {
        print "$Script: module $_ is far too big ($j/$gzsize bytes), skipping it\n";
      }
    }

    if($rb) {
      system "bin/mk_initrd";
      $isize = -s $initdisk;
      die "$Script: $initdisk missing" unless $isize > 0;
    }
  }

  for (@mlist) {
    $m = $mods[$mlist{$_}];
    die "$Script: oops" if $m eq "";
    if(-f "$initrddirx/$m") {
      SUSystem "mv $initrddirx/$m $initrddir/$_";
      push @xl, $_;
    }
  }
  die "$Script: failed to remove $initrddirx ($!)" unless rmdir $initrddirx;

  if(@xl) {
    print "$Script: modules dropped:\n";
    for (@xl) {
      $j = -s "$initrddir/$_";
      print "  $_ ($j bytes)\n"
    }
  }
}

