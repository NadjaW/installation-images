#! /usr/bin/perl

# Create an initrd and put everything on it.
#
# Source files and the file list are taken from data/initrd; the initrd is
# stored in images/initrd.
#
# Usage:        mk_initrd

=head1 mk_initrd

C<mk_initrd> creates an initial ram disk C<initrd>.

The files to go onto the ram disk (aka initrd) are taken from
C<data/initrd/initrd.file_list>.

The initrd uses a Ext2 file system. The actual fs size and inode numbers
are coded in the C<mk_initrd> script. You I<can> vary these values but it
doesn't really pay of much. You will gain or loose a few bytes of the
compressed initrd size only.

The final compressed image is stored as C<images/initrd>.

=cut

#'quote for emacs

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# the usual fuss...

BEGIN { unshift @INC, ( $0 =~ /(.*?)((?<![^\/])bin\/)?[^\/]+$/ )[0] . "lib" }
use ReadConfig;
use MakeMinixImage;
use MakeExt2Image;
use AddFiles;
use Conv2Image;
use CompressImage;

die "usage: $Script\n" if @ARGV;


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# some config data

$srcdir = "${DataPath}initrd";
$tmpdir = "${BasePath}tmp/initrd";
$tmpdir_root = "${BasePath}tmp/root";
$moddir = "${BasePath}tmp/initrd/modules";
$modlist = "${BasePath}tmp/initrd.modlist";
$tmpdirx = "${BasePath}tmp/.initrd";
$image = "${ImagePath}initrd";
$arch = "$ConfigData{arch}";
$gendir = "${DataPath}boot/gen";

# the compressed image size varies only slightly with these; about +-1k with
# reasonable inode/block combinations

# leave that much space
$extra_size = 600;		# kbyte
$extra_inodes = 200;

# just make them large enough
$start_size = 60000;		# kbyte
$start_inodes = 15000;

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# now we really start...

# default to 'large'
$ENV{'initrd'} = 'large' if $ENV{'initrd'} eq '';

$image = "${ImagePath}$ENV{'initrd_name'}" if $ENV{'initrd_name'};

$bootsplash = 0;
$bootsplash = 1 if $ENV{initrd} eq 'large' || $ENV{initrd} eq 'medium' || $ENV{bootsplash};
$bootsplash = 0 if $ENV{bootsplash} eq 'no' || $ENV{bootsplash} eq '0';

if($ENV{'keepinitrd'} != 1) {
  # clean up
  if(-d $tmpdir) {
    SUSystem "rm -rf $tmpdir" and
      die "$Script: failed to remove old $tmpdir";
  }
  if(-d $tmpdirx) {
    SUSystem "rm -rf $tmpdirx" and
      die "$Script: failed to remove old $tmpdirx";
  }

  SUSystem "rm -f ${BasePath}tmp/initrd.opt_mods";
  SUSystem "rm -f $modlist";

  $fl = "initrd";
  $fl = $ENV{'filelist'} if exists $ENV{'filelist'};

  AddFiles $tmpdir, "${srcdir}/$fl.file_list", $srcdir, $ENV{'initrd'}, "${BasePath}tmp/initrd.opt_mods" or
    die "$Script: failed to setup initrd image";

  if(!$ENV{with_gdb}) {
    print "stripping object files...\n";
    SUSystem "strip_dir $tmpdir";
  }
}

# on S/390, the initrd contains shared objects
if ($arch eq 's390' || $arch eq 's390x') {
    print "updating ld.so.cache...\n";
    SUSystem "ldconfig -r $tmpdir";
    die "$Script: failed to run ldconfig" unless -f "$tmpdir/etc/ld.so.cache";

    if($debug =~ /\bignore\b/ || $debug =~ /\bignorelibs\b/) {
      system "check_libs $tmpdir" and
	warn "$Script: error in shared lib config, please fix\n";
    }
    else {
      system "check_libs $tmpdir" and
	die "$Script: error in shared lib config, please fix\n";
    }    
}

@m = `ls $moddir/*.o 2>/dev/null`;
for (@m) {
  chomp;
  s#.*/##;
  s/\.o$//;
  push @m1, "$_\n"
}

open F, ">$modlist";
print F @m1;
close F;

# create the image
if($ENV{initrd_fs}) {
  $fstype = $ENV{initrd_fs};
}
else {
  $fstype = $arch eq 'i386' || $arch eq 'x86_64' ? 'minix' : 'ext2';
}

# add an inode for each symlink that will be added from the initrd to
# the instsys.  this nice idea creates an unwanted dependency between
# mk_root and mk_initrd:
#$extra_inodes += `CONDOM=echo $tmpdir_root/usr/bin/conservative_lndir $tmpdir_root $tmpdir | grep "^ln" | wc --lines`;
# thus we hardcode 800 additional inodes:
$extra_inodes += 800; 
Conv2Image $image, $tmpdir, $fstype, $start_size, $start_inodes, $extra_size, $extra_inodes;
$i = CompressImage $image;
print "$Script: compressed initrd to \"$image\" ($i bytes)\n";

# add boot splash
#if($bootsplash) {
#  system "tail -c4 $image >${image}.tmp";
#  system "cat ${BasePath}tmp/base/$ConfigData{splash_theme}.splash >>$image";
#  system "cat ${image}.tmp >>$image";
#  unlink "${image}.tmp";
#  $i = -s "$image";
#  print "$Script: $ConfigData{splash_theme} bootsplash added to \"$image\" (new size: $i bytes)\n";
#}

mkdir $gendir, 0755;

# add boot splash size
$i = 0;
if($bootsplash) {
  for (<${BasePath}tmp/base/$ConfigData{splash_theme}/*.spl>) {
    $j = -s;
    $i = !$i || $j < $i ? $j : $i;
  }
}

$i += -s $image;

die "$Script: $!" unless open F, ">$gendir/initrdsize";
print F "initrdsize\t", int(($i + 511) / 512), "\n";
close F;

